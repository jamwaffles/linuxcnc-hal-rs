/* automatically generated by rust-bindgen 0.61.0 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const RTAPI_NAME_LEN: u32 = 31;
pub const __GNUC_VA_LIST: u32 = 1;
pub const RTAPI_NO_FP: u32 = 0;
pub const RTAPI_USES_FP: u32 = 1;
pub const LINUX_VERSION_CODE: u32 = 0;
pub const _SPAWN_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 0;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 64;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 48;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const POSIX_SPAWN_RESETIDS: u32 = 1;
pub const POSIX_SPAWN_SETPGROUP: u32 = 2;
pub const POSIX_SPAWN_SETSIGDEF: u32 = 4;
pub const POSIX_SPAWN_SETSIGMASK: u32 = 8;
pub const POSIX_SPAWN_SETSCHEDPARAM: u32 = 16;
pub const POSIX_SPAWN_SETSCHEDULER: u32 = 32;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const HAL_NAME_LEN: u32 = 47;
pub const HAL_LOCK_NONE: u32 = 0;
pub const HAL_LOCK_LOAD: u32 = 1;
pub const HAL_LOCK_CONFIG: u32 = 2;
pub const HAL_LOCK_PARAMS: u32 = 4;
pub const HAL_LOCK_RUN: u32 = 8;
pub const HAL_LOCK_TUNE: u32 = 3;
pub const HAL_LOCK_ALL: u32 = 255;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _INTTYPES_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2usize] = b"l\0";
pub const PRId8: &[u8; 2usize] = b"d\0";
pub const PRId16: &[u8; 2usize] = b"d\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRId64: &[u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &[u8; 2usize] = b"d\0";
pub const PRIdFAST16: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &[u8; 3usize] = b"ld\0";
pub const PRIi8: &[u8; 2usize] = b"i\0";
pub const PRIi16: &[u8; 2usize] = b"i\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIi64: &[u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &[u8; 3usize] = b"li\0";
pub const PRIiFAST8: &[u8; 2usize] = b"i\0";
pub const PRIiFAST16: &[u8; 3usize] = b"li\0";
pub const PRIiFAST32: &[u8; 3usize] = b"li\0";
pub const PRIiFAST64: &[u8; 3usize] = b"li\0";
pub const PRIo8: &[u8; 2usize] = b"o\0";
pub const PRIo16: &[u8; 2usize] = b"o\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIo64: &[u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &[u8; 2usize] = b"o\0";
pub const PRIoFAST16: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &[u8; 3usize] = b"lo\0";
pub const PRIu8: &[u8; 2usize] = b"u\0";
pub const PRIu16: &[u8; 2usize] = b"u\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIu64: &[u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &[u8; 2usize] = b"u\0";
pub const PRIuFAST16: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &[u8; 3usize] = b"lu\0";
pub const PRIx8: &[u8; 2usize] = b"x\0";
pub const PRIx16: &[u8; 2usize] = b"x\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIx64: &[u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &[u8; 2usize] = b"x\0";
pub const PRIxFAST16: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &[u8; 3usize] = b"lx\0";
pub const PRIX8: &[u8; 2usize] = b"X\0";
pub const PRIX16: &[u8; 2usize] = b"X\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRIX64: &[u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &[u8; 2usize] = b"X\0";
pub const PRIXFAST16: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &[u8; 3usize] = b"lX\0";
pub const PRIdMAX: &[u8; 3usize] = b"ld\0";
pub const PRIiMAX: &[u8; 3usize] = b"li\0";
pub const PRIoMAX: &[u8; 3usize] = b"lo\0";
pub const PRIuMAX: &[u8; 3usize] = b"lu\0";
pub const PRIxMAX: &[u8; 3usize] = b"lx\0";
pub const PRIXMAX: &[u8; 3usize] = b"lX\0";
pub const PRIdPTR: &[u8; 3usize] = b"ld\0";
pub const PRIiPTR: &[u8; 3usize] = b"li\0";
pub const PRIoPTR: &[u8; 3usize] = b"lo\0";
pub const PRIuPTR: &[u8; 3usize] = b"lu\0";
pub const PRIxPTR: &[u8; 3usize] = b"lx\0";
pub const PRIXPTR: &[u8; 3usize] = b"lX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNd64: &[u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &[u8; 3usize] = b"ld\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNi64: &[u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &[u8; 3usize] = b"li\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3usize] = b"li\0";
pub const SCNiFAST32: &[u8; 3usize] = b"li\0";
pub const SCNiFAST64: &[u8; 3usize] = b"li\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNu64: &[u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &[u8; 3usize] = b"lu\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNo64: &[u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &[u8; 3usize] = b"lo\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNx64: &[u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &[u8; 3usize] = b"lx\0";
pub const SCNdMAX: &[u8; 3usize] = b"ld\0";
pub const SCNiMAX: &[u8; 3usize] = b"li\0";
pub const SCNoMAX: &[u8; 3usize] = b"lo\0";
pub const SCNuMAX: &[u8; 3usize] = b"lu\0";
pub const SCNxMAX: &[u8; 3usize] = b"lx\0";
pub const SCNdPTR: &[u8; 3usize] = b"ld\0";
pub const SCNiPTR: &[u8; 3usize] = b"li\0";
pub const SCNoPTR: &[u8; 3usize] = b"lo\0";
pub const SCNuPTR: &[u8; 3usize] = b"lu\0";
pub const SCNxPTR: &[u8; 3usize] = b"lx\0";
pub const RTAPI_INT8_MAX: u32 = 127;
pub const RTAPI_INT8_MIN: i32 = -128;
pub const RTAPI_UINT8_MAX: u32 = 255;
pub const RTAPI_INT16_MAX: u32 = 32767;
pub const RTAPI_INT16_MIN: i32 = -32768;
pub const RTAPI_UINT16_MAX: u32 = 65535;
pub const RTAPI_INT32_MAX: u32 = 2147483647;
pub const RTAPI_INT32_MIN: i32 = -2147483648;
pub const RTAPI_UINT32_MAX: u32 = 4294967295;
pub const HAL_STREAM_MAX_PINS: u32 = 21;
pub type wchar_t = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    #[doc = " 'rtapi_init() sets up the RTAPI.  It must be called by any"]
    #[doc = "module that intends to use the API, before any other RTAPI"]
    #[doc = "calls."]
    #[doc = "'modname' can optionally point to a string that identifies"]
    #[doc = "the module.  The string will be truncated at RTAPI_NAME_LEN"]
    #[doc = "characters.  If 'modname' is NULL, the system will assign a"]
    #[doc = "name."]
    #[doc = "On success, returns a positive integer module ID, which is"]
    #[doc = "used for subsequent calls to rtapi_xxx_new, rtapi_xxx_delete,"]
    #[doc = "and rtapi_exit.  On failure, returns an error code as defined"]
    #[doc = "above.  Call only from within user or init/cleanup code, not"]
    #[doc = "from realtime tasks."]
    pub fn rtapi_init(modname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_exit()' shuts down and cleans up the RTAPI.  It must be"]
    #[doc = "called prior to exit by any module that called rtapi_init."]
    #[doc = "'module_id' is the ID code returned when that module called"]
    #[doc = "rtapi_init()."]
    #[doc = "Returns a status code.  rtapi_exit() may attempt to clean up"]
    #[doc = "any tasks, shared memory, and other resources allocated by the"]
    #[doc = "module, but should not be relied on to replace proper cleanup"]
    #[doc = "code within the module.  Call only from within user or"]
    #[doc = "init/cleanup code, not from realtime tasks."]
    pub fn rtapi_exit(module_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_snprintf()' works like 'snprintf()' from the normal"]
    #[doc = "C library, except that it may not handle long longs."]
    #[doc = "It is provided here because some RTOS kernels don't provide"]
    #[doc = "a realtime safe version of the function, and those that do don't provide"]
    #[doc = "support for printing doubles.  On systems with a"]
    #[doc = "good kernel snprintf(), or in user space, this function"]
    #[doc = "simply calls the normal snprintf().  May be called from user,"]
    #[doc = "init/cleanup, and realtime code."]
    pub fn rtapi_snprintf(
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_ulong,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type va_list = [u64; 4usize];
pub type __gnuc_va_list = [u64; 4usize];
extern "C" {
    pub fn rtapi_vsnprintf(
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_ulong,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_print()' prints a printf style message.  Depending on the"]
    #[doc = "RTOS and whether the program is being compiled for user space"]
    #[doc = "or realtime, the message may be printed to stdout, stderr, or"]
    #[doc = "to a kernel message log, etc.  The calling syntax and format"]
    #[doc = "string is similar to printf except that floating point and"]
    #[doc = "longlongs are NOT supported in realtime and may not be supported"]
    #[doc = "in user space.  For some RTOS's, a 80 byte buffer is used, so the"]
    #[doc = "format line and arguments should not produce a line more than"]
    #[doc = "80 bytes long.  (The buffer is protected against overflow.)"]
    #[doc = "Does not block, but  can take a fairly long time, depending on"]
    #[doc = "the format string and OS.  May be called from user, init/cleanup,"]
    #[doc = "and realtime code."]
    pub fn rtapi_print(fmt: *const ::std::os::raw::c_char, ...);
}
pub const msg_level_t_RTAPI_MSG_NONE: msg_level_t = 0;
pub const msg_level_t_RTAPI_MSG_ERR: msg_level_t = 1;
pub const msg_level_t_RTAPI_MSG_WARN: msg_level_t = 2;
pub const msg_level_t_RTAPI_MSG_INFO: msg_level_t = 3;
pub const msg_level_t_RTAPI_MSG_DBG: msg_level_t = 4;
pub const msg_level_t_RTAPI_MSG_ALL: msg_level_t = 5;
#[doc = " 'rtapi_print_msg()' prints a printf-style message when the level"]
#[doc = "is less than or equal to the current message level set by"]
#[doc = "rtapi_set_msg_level().  May be called from user, init/cleanup,"]
#[doc = "and realtime code."]
pub type msg_level_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn rtapi_print_msg(level: msg_level_t, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Set the maximum level of message to print.  In userspace code,"]
    #[doc = "each component has its own independent message level.  In realtime"]
    #[doc = "code, all components share a single message level.  Returns 0 for"]
    #[doc = "success or -EINVAL if the level is out of range."]
    pub fn rtapi_set_msg_level(level: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the message level set by the last call to rtapi_set_msg_level"]
    pub fn rtapi_get_msg_level() -> ::std::os::raw::c_int;
}
#[doc = " 'rtapi_get_msg_handler' and 'rtapi_set_msg_handler' access the function"]
#[doc = "pointer used by rtapi_print and rtapi_print_msg.  By default, messages"]
#[doc = "appear in the kernel log, but by replacing the handler a user of the rtapi"]
#[doc = "library can send the messages to another destination.  Calling"]
#[doc = "rtapi_set_msg_handler with NULL restores the default handler. Call from"]
#[doc = "real-time init/cleanup code only.  When called from rtapi_print(),"]
#[doc = "'level' is RTAPI_MSG_ALL, a level which should not normally be used"]
#[doc = "with rtapi_print_msg()."]
pub type rtapi_msg_handler_t = ::std::option::Option<
    unsafe extern "C" fn(level: msg_level_t, fmt: *const ::std::os::raw::c_char, ap: va_list),
>;
extern "C" {
    pub fn rtapi_set_msg_handler(handler: rtapi_msg_handler_t);
}
extern "C" {
    pub fn rtapi_get_msg_handler() -> rtapi_msg_handler_t;
}
extern "C" {
    #[doc = " 'rtapi_clock_set_period() sets the basic time interval for realtime"]
    #[doc = "tasks.  All periodic tasks will run at an integer multiple of this"]
    #[doc = "period.  The first call to 'rtapi_clock_set_period() with 'nsecs'"]
    #[doc = "greater than zero will start the clock, using 'nsecs' as the clock"]
    #[doc = "period in nano-seconds.  Due to hardware and RTOS limitations, the"]
    #[doc = "actual period may not be exactly what was requested.  On success,"]
    #[doc = "the function will return the actual clock period if it is available,"]
    #[doc = "otherwise it returns the requested period.  If the requested period"]
    #[doc = "is outside the limits imposed by the hardware or RTOS, it returns"]
    #[doc = "-EINVAL and does not start the clock.  Once the clock is started,"]
    #[doc = "subsequent calls with non-zero 'nsecs' return -EINVAL and have"]
    #[doc = "no effect.  Calling 'rtapi_clock_set_period() with 'nsecs' set to"]
    #[doc = "zero queries the clock, returning the current clock period, or zero"]
    #[doc = "if the clock has not yet been started.  Call only from within"]
    #[doc = "init/cleanup code, not from realtime tasks.  This function is not"]
    #[doc = "available from user (non-realtime) code."]
    pub fn rtapi_clock_set_period(nsecs: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " rtapi_delay() is a simple delay.  It is intended only for short"]
    #[doc = "delays, since it simply loops, wasting CPU cycles.  'nsec' is the"]
    #[doc = "desired delay, in nano-seconds.  'rtapi_delay_max() returns the"]
    #[doc = "max delay permitted (usually approximately 1/4 of the clock period)."]
    #[doc = "Any call to 'rtapi_delay()' requesting a delay longer than the max"]
    #[doc = "will delay for the max time only.  'rtapi_delay_max()' should be"]
    #[doc = "called before using 'rtapi_delay()' to make sure the required delays"]
    #[doc = "can be achieved.  The actual resolution of the delay may be as good"]
    #[doc = "as one nano-second, or as bad as a several microseconds.  May be"]
    #[doc = "called from init/cleanup code, and from within realtime tasks."]
    pub fn rtapi_delay(nsec: ::std::os::raw::c_long);
}
extern "C" {
    pub fn rtapi_delay_max() -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " rtapi_get_time returns the current time in nanoseconds.  Depending"]
    #[doc = "on the RTOS, this may be time since boot, or time since the clock"]
    #[doc = "period was set, or some other time.  Its absolute value means"]
    #[doc = "nothing, but it is monotonically increasing and can be used to"]
    #[doc = "schedule future events, or to time the duration of some activity."]
    #[doc = "Returns a 64 bit value.  The resolution of the returned value may"]
    #[doc = "be as good as one nano-second, or as poor as several microseconds."]
    #[doc = "May be called from init/cleanup code, and from within realtime tasks."]
    #[doc = ""]
    #[doc = "Experience has shown that the implementation of this function in"]
    #[doc = "some RTOS/Kernel combinations is horrible.  It can take up to"]
    #[doc = "several microseconds, which is at least 100 times longer than it"]
    #[doc = "should, and perhaps a thousand times longer.  Use it only if you"]
    #[doc = "MUST have results in seconds instead of clocks, and use it sparingly."]
    #[doc = "See rtapi_get_clocks() instead."]
    #[doc = ""]
    #[doc = "Note that longlong math may be poorly supported on some platforms,"]
    #[doc = "especially in kernel space. Also note that rtapi_print() will NOT"]
    #[doc = "print longlongs.  Most time measurements are relative, and should"]
    #[doc = "be done like this:  deltat = (long int)(end_time - start_time);"]
    #[doc = "where end_time and start_time are longlong values returned from"]
    #[doc = "rtapi_get_time, and deltat is an ordinary long int (32 bits)."]
    #[doc = "This will work for times up to about 2 seconds."]
    pub fn rtapi_get_time() -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " rtapi_get_clocks returns the current time in CPU clocks.  It is"]
    #[doc = "fast, since it just reads the TSC in the CPU instead of calling a"]
    #[doc = "kernel or RTOS function.  Of course, times measured in CPU clocks"]
    #[doc = "are not as convenient, but for relative measurements this works"]
    #[doc = "fine.  Its absolute value means nothing, but it is monotonically"]
    #[doc = "increasing* and can be used to schedule future events, or to time"]
    #[doc = "the duration of some activity.  (* on SMP machines, the two TSC's"]
    #[doc = "may get out of sync, so if a task reads the TSC, gets swapped to"]
    #[doc = "the other CPU, and reads again, the value may decrease.  RTAPI"]
    #[doc = "tries to force all RT tasks to run on one CPU.)"]
    #[doc = "Returns a 64 bit value.  The resolution of the returned value is"]
    #[doc = "one CPU clock, which is usually a few nanoseconds to a fraction of"]
    #[doc = "a nanosecond."]
    #[doc = "May be called from init/cleanup code, and from within realtime tasks."]
    #[doc = ""]
    #[doc = "Note that longlong math may be poorly supported on some platforms,"]
    #[doc = "especially in kernel space. Also note that rtapi_print() will NOT"]
    #[doc = "print longlongs.  Most time measurements are relative, and should"]
    #[doc = "be done like this:  deltat = (long int)(end_time - start_time);"]
    #[doc = "where end_time and start_time are longlong values returned from"]
    #[doc = "rtapi_get_time, and deltat is an ordinary long int (32 bits)."]
    #[doc = "This will work for times up to a second or so, depending on the"]
    #[doc = "CPU clock frequency.  It is best used for millisecond and"]
    #[doc = "microsecond scale measurements though."]
    pub fn rtapi_get_clocks() -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " The 'rtapi_prio_xxxx()' functions provide a portable way to set"]
    #[doc = "task priority.  The mapping of actual priority to priority number"]
    #[doc = "depends on the RTOS.  Priorities range from 'rtapi_prio_lowest()'"]
    #[doc = "to 'rtapi_prio_highest()', inclusive. To use this API, use one of"]
    #[doc = "two methods:"]
    #[doc = ""]
    #[doc = "1) Set your lowest priority task to 'rtapi_prio_lowest()', and for"]
    #[doc = "each task of the next lowest priority, set their priorities to"]
    #[doc = "'rtapi_prio_next_higher(previous)'."]
    #[doc = ""]
    #[doc = "2) Set your highest priority task to 'rtapi_prio_highest()', and"]
    #[doc = "for each task of the next highest priority, set their priorities"]
    #[doc = "to 'rtapi_prio_next_lower(previous)'."]
    #[doc = ""]
    #[doc = "A high priority task will preempt a lower priority task.  The linux kernel"]
    #[doc = "and userspace are always a lower priority than all rtapi tasks."]
    #[doc = ""]
    #[doc = "Call these functions only from within init/cleanup code, not from"]
    #[doc = "realtime tasks."]
    pub fn rtapi_prio_highest() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtapi_prio_lowest() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtapi_prio_next_higher(prio: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtapi_prio_next_lower(prio: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtapi_task_new(
        taskcode: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        arg: *mut ::std::os::raw::c_void,
        prio: ::std::os::raw::c_int,
        owner: ::std::os::raw::c_int,
        stacksize: ::std::os::raw::c_ulong,
        uses_fp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_task_delete()' deletes a task.  'task_id' is a task ID"]
    #[doc = "from a previous call to rtapi_task_new().  It frees memory"]
    #[doc = "associated with 'task', and does any other cleanup needed.  If"]
    #[doc = "the task has been started, you should pause it before deleting"]
    #[doc = "it.  Returns a status code.  Call only from within init/cleanup"]
    #[doc = "code, not from realtime tasks."]
    pub fn rtapi_task_delete(task_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_task_start()' starts a task in periodic mode.  'task_id' is"]
    #[doc = "a task ID from a call to rtapi_task_new().  The task must be in"]
    #[doc = "the \"paused\" state, or it will return -EINVAL."]
    #[doc = "'period_nsec' is the task period in nanoseconds, which will be"]
    #[doc = "rounded to the nearest multiple of the global clock period.  A"]
    #[doc = "task period less than the clock period (including zero) will be"]
    #[doc = "set equal to the clock period."]
    #[doc = "Call only from within init/cleanup code, not from realtime tasks."]
    pub fn rtapi_task_start(
        task_id: ::std::os::raw::c_int,
        period_nsec: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_wait()' suspends execution of the current task until the"]
    #[doc = "next period.  The task must be periodic, if not, the result is"]
    #[doc = "undefined.  The function will return at the beginning of the"]
    #[doc = "next period.  Call only from within a realtime task."]
    pub fn rtapi_wait();
}
extern "C" {
    #[doc = " 'rtapi_task_resume() starts a task in free-running mode. 'task_id'"]
    #[doc = "is a task ID from a call to rtapi_task_new().  The task must be in"]
    #[doc = "the \"paused\" state, or it will return -EINVAL."]
    #[doc = "A free running task runs continuously until either:"]
    #[doc = "1) It is prempted by a higher priority task.  It will resume as"]
    #[doc = "soon as the higher priority task releases the CPU."]
    #[doc = "2) It calls a blocking function, like rtapi_sem_take().  It will"]
    #[doc = "resume when the function unblocks."]
    #[doc = "3) it is returned to the \"paused\" state by rtapi_task_pause()."]
    #[doc = "May be called from init/cleanup code, and from within realtime tasks."]
    pub fn rtapi_task_resume(task_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_task_pause() causes 'task_id' to stop execution and change"]
    #[doc = "to the \"paused\" state.  'task_id' can be free-running or periodic."]
    #[doc = "Note that rtapi_task_pause() may called from any task, or from init"]
    #[doc = "or cleanup code, not just from the task that is to be paused."]
    #[doc = "The task will resume execution when either rtapi_task_resume() or"]
    #[doc = "rtapi_task_start() is called.  May be called from init/cleanup code,"]
    #[doc = "and from within realtime tasks."]
    pub fn rtapi_task_pause(task_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_task_self()' returns the task ID of the current task or -EINVAL."]
    #[doc = "May be called from init/cleanup code, and from within realtime tasks."]
    pub fn rtapi_task_self() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_shmem_new()' allocates a block of shared memory.  'key'"]
    #[doc = "identifies the memory block, and must be non-zero.  All modules"]
    #[doc = "wishing to access the same memory must use the same key."]
    #[doc = "'module_id' is the ID of the module that is making the call (see"]
    #[doc = "rtapi_init).  The block will be at least 'size' bytes, and may"]
    #[doc = "be rounded up.  Allocating many small blocks may be very wasteful."]
    #[doc = "When a particular block is allocated for the first time, all"]
    #[doc = "bytes are zeroed.  Subsequent allocations of the same block"]
    #[doc = "by other modules or processes will not touch the contents of the"]
    #[doc = "block."]
    #[doc = "On success, it returns a positive integer ID, which is used for"]
    #[doc = "all subsequent calls dealing with the block.  On failure it"]
    #[doc = "returns a negative error code.  Call only from within user or"]
    #[doc = "init/cleanup code, not from realtime tasks."]
    pub fn rtapi_shmem_new(
        key: ::std::os::raw::c_int,
        module_id: ::std::os::raw::c_int,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_shmem_delete()' frees the shared memory block associated"]
    #[doc = "with 'shmem_id'.  'module_id' is the ID of the calling module."]
    #[doc = "Returns a status code.  Call only from within user or init/cleanup"]
    #[doc = "code, not from realtime tasks."]
    pub fn rtapi_shmem_delete(
        shmem_id: ::std::os::raw::c_int,
        module_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_shmem_getptr()' sets '*ptr' to point to shared memory block"]
    #[doc = "associated with 'shmem_id'.  Returns a status code.  May be called"]
    #[doc = "from user code, init/cleanup code, or realtime tasks."]
    pub fn rtapi_shmem_getptr(
        shmem_id: ::std::os::raw::c_int,
        ptr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_sem_new()' creates a realtime semaphore.  'key' identifies"]
    #[doc = "identifies the semaphore, and must be non-zero.  All modules wishing"]
    #[doc = "to use the same semaphore must specify the same key.  'module_id'"]
    #[doc = "is the ID of the module making the call (see rtapi_init).  On"]
    #[doc = "success, it returns a positive integer semaphore ID, which is used"]
    #[doc = "for all subsequent calls dealing with the semaphore.  On failure"]
    #[doc = "it returns a negative error code.  Call only from within init/cleanup"]
    #[doc = "code, not from realtime tasks."]
    pub fn rtapi_sem_new(
        key: ::std::os::raw::c_int,
        module_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_sem_delete()' is the counterpart to 'rtapi_sem_new()'.  It"]
    #[doc = "discards the semaphore associated with 'sem_id'.  Any tasks blocked"]
    #[doc = "on 'sem' will resume execution.  'module_id' is the ID of the calling"]
    #[doc = "module.  Returns a status code.  Call only from within init/cleanup"]
    #[doc = "code, not from realtime tasks."]
    pub fn rtapi_sem_delete(
        sem_id: ::std::os::raw::c_int,
        module_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_sem_give()' unlocks a semaphore.  If a higher priority task"]
    #[doc = "is blocked on the semaphore, the calling task will block and the"]
    #[doc = "higher priority task will begin to run.  Returns a status code."]
    #[doc = "May be called from init/cleanup code, and from within realtime tasks."]
    pub fn rtapi_sem_give(sem_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_sem_take()' locks a semaphore.  Returns 0 or"]
    #[doc = "-EINVAL.  If the semaphore is unlocked it returns 0"]
    #[doc = "immediately.  If the semaphore is locked, the calling task blocks"]
    #[doc = "until the semaphore is unlocked, then it returns 0."]
    #[doc = "Call only from within a realtime task."]
    pub fn rtapi_sem_take(sem_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_sem_try()' does a non-blocking attempt to lock a semaphore."]
    #[doc = "Returns 0, -EINVAL, or -EBUSY.  If the semaphore"]
    #[doc = "is unlocked, it returns 0.  If the semaphore is locked"]
    #[doc = "it does not block, instead it returns -EBUSY, and the caller"]
    #[doc = "can decide how to deal with the situation.  Call only from within"]
    #[doc = "a realtime task."]
    pub fn rtapi_sem_try(sem_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_fifo_new()' creates a realtime fifo. 'key' identifies the"]
    #[doc = "fifo, all modules wishing to access the same fifo must use the same"]
    #[doc = "key.  'module_id' is the ID of the module making the call (see"]
    #[doc = "rtapi_init).  'size' is the depth of the fifo.  'mode' is either"]
    #[doc = "'R' or 'W', to request either read or write access to the fifo."]
    #[doc = "On success, it returns a positive integer ID, which is used for"]
    #[doc = "subsequent calls dealing with the fifo.  On failure, returns a"]
    #[doc = "negative error code.  Call only from within user or init/cleanup"]
    #[doc = "code, not from realtime tasks."]
    pub fn rtapi_fifo_new(
        key: ::std::os::raw::c_int,
        module_id: ::std::os::raw::c_int,
        size: ::std::os::raw::c_ulong,
        mode: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_fifo_delete()' is the counterpart to 'rtapi_fifo_new()'."]
    #[doc = "It closes the fifo associated with 'fifo_ID'.  'module_id' is the"]
    #[doc = "ID of the calling module.  Returns status code.  Call only from"]
    #[doc = "within user or init/cleanup code, not from realtime tasks."]
    pub fn rtapi_fifo_delete(
        fifo_id: ::std::os::raw::c_int,
        module_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtapi_fifo_read(
        fifo_id: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtapi_fifo_write(
        fifo_id: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_assign_interrupt_handler()' is used to set up a handler for"]
    #[doc = "a hardware interrupt.  'irq' is the interrupt number, and 'handler'"]
    #[doc = "is a pointer to a function taking no arguments and returning void."]
    #[doc = "'handler will be called when the interrupt occurs.  'owner' is the"]
    #[doc = "ID of the calling module (see rtapi_init).  Returns a status"]
    #[doc = "code.  Note:  The simulated RTOS does not support interrupts."]
    #[doc = "Call only from within init/cleanup code, not from realtime tasks."]
    pub fn rtapi_irq_new(
        irq_num: ::std::os::raw::c_uint,
        owner: ::std::os::raw::c_int,
        handler: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_free_interrupt_handler()' removes an interrupt handler that"]
    #[doc = "was previously installed by rtapi_assign_interrupt_handler(). 'irq'"]
    #[doc = "is the interrupt number.  Removing a realtime module without freeing"]
    #[doc = "any handlers it has installed will almost certainly crash the box."]
    #[doc = "Returns 0 or -EINVAL.  Call only from within"]
    #[doc = "init/cleanup code, not from realtime tasks."]
    pub fn rtapi_irq_delete(irq_num: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_enable_interrupt()' and 'rtapi_disable_interrupt()' are"]
    #[doc = "are used to enable and disable interrupts, presumably ones that"]
    #[doc = "have handlers assigned to them.  Returns a status code.  May be"]
    #[doc = "called from init/cleanup code, and from within realtime tasks."]
    pub fn rtapi_enable_interrupt(irq: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtapi_disable_interrupt(irq: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'rtapi_outb() writes 'byte' to 'port'.  May be called from"]
    #[doc = "init/cleanup code, and from within realtime tasks."]
    #[doc = "Note: This function does nothing on the simulated RTOS."]
    #[doc = "Note: Many platforms provide an inline outb() that is faster."]
    pub fn rtapi_outb(byte: ::std::os::raw::c_uchar, port: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " 'rtapi_inb() gets a byte from 'port'.  Returns the byte.  May"]
    #[doc = "be called from init/cleanup code, and from within realtime tasks."]
    #[doc = "Note: This function always returns zero on the simulated RTOS."]
    #[doc = "Note: Many platforms provide an inline inb() that is faster."]
    pub fn rtapi_inb(port: ::std::os::raw::c_uint) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn simple_strtol(
        nptr: *const ::std::os::raw::c_char,
        endptr: *mut *mut ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_uint;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_int;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::std::mem::MaybeUninit<sched_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_set_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_int,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __pad1: ::std::os::raw::c_ulong,
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 64usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_spawnattr_t {
    pub __flags: ::std::os::raw::c_short,
    pub __pgrp: pid_t,
    pub __sd: sigset_t,
    pub __ss: sigset_t,
    pub __sp: sched_param,
    pub __policy: ::std::os::raw::c_int,
    pub __pad: [::std::os::raw::c_int; 16usize],
}
#[test]
fn bindgen_test_layout_posix_spawnattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<posix_spawnattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<posix_spawnattr_t>(),
        336usize,
        concat!("Size of: ", stringify!(posix_spawnattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<posix_spawnattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(posix_spawnattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawnattr_t),
            "::",
            stringify!(__flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pgrp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawnattr_t),
            "::",
            stringify!(__pgrp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawnattr_t),
            "::",
            stringify!(__sd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawnattr_t),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawnattr_t),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__policy) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawnattr_t),
            "::",
            stringify!(__policy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawnattr_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_spawn_file_actions_t {
    pub __allocated: ::std::os::raw::c_int,
    pub __used: ::std::os::raw::c_int,
    pub __actions: *mut __spawn_action,
    pub __pad: [::std::os::raw::c_int; 16usize],
}
#[test]
fn bindgen_test_layout_posix_spawn_file_actions_t() {
    const UNINIT: ::std::mem::MaybeUninit<posix_spawn_file_actions_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<posix_spawn_file_actions_t>(),
        80usize,
        concat!("Size of: ", stringify!(posix_spawn_file_actions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<posix_spawn_file_actions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(posix_spawn_file_actions_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__allocated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawn_file_actions_t),
            "::",
            stringify!(__allocated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__used) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawn_file_actions_t),
            "::",
            stringify!(__used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__actions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawn_file_actions_t),
            "::",
            stringify!(__actions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawn_file_actions_t),
            "::",
            stringify!(__pad)
        )
    );
}
extern "C" {
    pub fn posix_spawn(
        __pid: *mut pid_t,
        __path: *const ::std::os::raw::c_char,
        __file_actions: *const posix_spawn_file_actions_t,
        __attrp: *const posix_spawnattr_t,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnp(
        __pid: *mut pid_t,
        __file: *const ::std::os::raw::c_char,
        __file_actions: *const posix_spawn_file_actions_t,
        __attrp: *const posix_spawnattr_t,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_init(__attr: *mut posix_spawnattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_destroy(__attr: *mut posix_spawnattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_getsigdefault(
        __attr: *const posix_spawnattr_t,
        __sigdefault: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_setsigdefault(
        __attr: *mut posix_spawnattr_t,
        __sigdefault: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_getsigmask(
        __attr: *const posix_spawnattr_t,
        __sigmask: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_setsigmask(
        __attr: *mut posix_spawnattr_t,
        __sigmask: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_getflags(
        __attr: *const posix_spawnattr_t,
        __flags: *mut ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_setflags(
        _attr: *mut posix_spawnattr_t,
        __flags: ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_getpgroup(
        __attr: *const posix_spawnattr_t,
        __pgroup: *mut pid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_setpgroup(
        __attr: *mut posix_spawnattr_t,
        __pgroup: pid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_getschedpolicy(
        __attr: *const posix_spawnattr_t,
        __schedpolicy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_setschedpolicy(
        __attr: *mut posix_spawnattr_t,
        __schedpolicy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_getschedparam(
        __attr: *const posix_spawnattr_t,
        __schedparam: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_setschedparam(
        __attr: *mut posix_spawnattr_t,
        __schedparam: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawn_file_actions_init(
        __file_actions: *mut posix_spawn_file_actions_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawn_file_actions_destroy(
        __file_actions: *mut posix_spawn_file_actions_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawn_file_actions_addopen(
        __file_actions: *mut posix_spawn_file_actions_t,
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        __mode: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawn_file_actions_addclose(
        __file_actions: *mut posix_spawn_file_actions_t,
        __fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawn_file_actions_adddup2(
        __file_actions: *mut posix_spawn_file_actions_t,
        __fd: ::std::os::raw::c_int,
        __newfd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtapi_spawn_as_root(
        pid: *mut pid_t,
        path: *const ::std::os::raw::c_char,
        file_actions: *const posix_spawn_file_actions_t,
        attrp: *const posix_spawnattr_t,
        argv: *const *mut ::std::os::raw::c_char,
        envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtapi_spawnp_as_root(
        pid: *mut pid_t,
        path: *const ::std::os::raw::c_char,
        file_actions: *const posix_spawn_file_actions_t,
        attrp: *const posix_spawnattr_t,
        argv: *const *mut ::std::os::raw::c_char,
        envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtapi_is_kernelspace() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtapi_is_realtime() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtapi_open_as_root(
        filename: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_init()' is called by a HAL component before any other hal"]
    #[doc = "function is called, to open the HAL shared memory block and"]
    #[doc = "do other initialization."]
    #[doc = "'name' is the name of the component.  It must be unique in the"]
    #[doc = "system.  It must be no longer than HAL_NAME_LEN."]
    #[doc = "On success, hal_init() returns a positive integer component ID,"]
    #[doc = "which is used for subsequent calls to hal_xxx_new() and"]
    #[doc = "hal_exit().  On failure, returns an error code (see above)."]
    #[doc = "'hal_init()' calls rtapi_init(), so after calling hal_init(), a"]
    #[doc = "component can use any rtapi functions.  The component ID returned"]
    #[doc = "by 'hal_init()' is also the RTAPI module ID for the associated"]
    #[doc = "module, and can be used when calling rtapi functions."]
    #[doc = "Call only from within user space or init/cleanup code, not from"]
    #[doc = "realtime code."]
    pub fn hal_init(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_exit()' must be called before a HAL component exits, to"]
    #[doc = "free resources associated with the component."]
    #[doc = "'comp_id' is the ID of the component as returned from its initial"]
    #[doc = "call to 'hal_init()'.  'hal_exit()' will remove the component's"]
    #[doc = "realtime functions (if any) from realtime threads.  It also"]
    #[doc = "removes all pins and parameters exported by the component.  If"]
    #[doc = "the component created _any_ threads, when it exits _all_ threads"]
    #[doc = "will be stopped, and the ones it created will be deleted."]
    #[doc = "It is assumed that the system will no longer function correctly"]
    #[doc = "after a component is removed, but this cleanup will prevent"]
    #[doc = "crashes when the component's code and data is unmapped."]
    #[doc = "'hal_exit()' calls 'rtapi_exit()', so any rtapi reaources"]
    #[doc = "allocated should be discarded before calling hal_exit(), and"]
    #[doc = "rtapi functions should not be called afterwards."]
    #[doc = "On success, hal_exit() returns 0, on failure it"]
    #[doc = "returns a negative error code."]
    pub fn hal_exit(comp_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_malloc() allocates a block of memory from the main HAL"]
    #[doc = "shared memory area.  It should be used by all components to"]
    #[doc = "allocate memory for HAL pins and parameters."]
    #[doc = "It allocates 'size' bytes, and returns a pointer to the"]
    #[doc = "allocated space, or NULL (0) on error.  The returned pointer"]
    #[doc = "will be properly aligned for any variable HAL supports (see"]
    #[doc = "HAL_TYPE below.)"]
    #[doc = "The allocator is very simple, and there is no 'free'.  It is"]
    #[doc = "assumed that a component will allocate all the memory it needs"]
    #[doc = "during initialization.  The entire HAL shared memory area is"]
    #[doc = "freed when the last component calls hal_exit().  This means"]
    #[doc = "that if you continuously install and remove one component"]
    #[doc = "while other components are present, you eventually will fill"]
    #[doc = "up the shared memory and an install will fail.  Removing"]
    #[doc = "all components completely clears memory and you start"]
    #[doc = "fresh."]
    pub fn hal_malloc(size: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " hal_ready() indicates that this component is ready.  This allows"]
    #[doc = "halcmd 'loadusr -W hal_example' to wait until the userspace"]
    #[doc = "component 'hal_example' is ready before continuing."]
    pub fn hal_ready(comp_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_unready() indicates that this component is ready.  This allows"]
    #[doc = "halcmd 'loadusr -W hal_example' to wait until the userspace"]
    #[doc = "component 'hal_example' is ready before continuing."]
    pub fn hal_unready(comp_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_comp_name() returns the name of the given component, or NULL"]
    #[doc = "if comp_id is not a loaded component"]
    pub fn hal_comp_name(comp_id: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
pub const hal_type_t_HAL_TYPE_UNSPECIFIED: hal_type_t = -1;
pub const hal_type_t_HAL_TYPE_UNINITIALIZED: hal_type_t = 0;
pub const hal_type_t_HAL_BIT: hal_type_t = 1;
pub const hal_type_t_HAL_FLOAT: hal_type_t = 2;
pub const hal_type_t_HAL_S32: hal_type_t = 3;
pub const hal_type_t_HAL_U32: hal_type_t = 4;
pub const hal_type_t_HAL_PORT: hal_type_t = 5;
#[doc = " HAL pins and signals are typed, and the HAL only allows pins"]
#[doc = "to be attached to signals of the same type."]
#[doc = "All HAL types can be read or written atomically.  (Read-modify-"]
#[doc = "write operations are not atomic.)"]
#[doc = "Note that when a component reads or writes one of its pins, it"]
#[doc = "is actually reading or writing the signal linked to that pin, by"]
#[doc = "way of the pointer."]
#[doc = "'hal_type_t' is an enum used to identify the type of a pin, signal,"]
#[doc = "or parameter."]
pub type hal_type_t = ::std::os::raw::c_int;
pub const hal_pin_dir_t_HAL_DIR_UNSPECIFIED: hal_pin_dir_t = -1;
pub const hal_pin_dir_t_HAL_IN: hal_pin_dir_t = 16;
pub const hal_pin_dir_t_HAL_OUT: hal_pin_dir_t = 32;
pub const hal_pin_dir_t_HAL_IO: hal_pin_dir_t = 48;
#[doc = " HAL pins have a direction attribute.  A pin may be an input to"]
#[doc = "the HAL component, an output, or it may be bidirectional."]
#[doc = "Any number of HAL_IN or HAL_IO pins may be connected to the same"]
#[doc = "signal, but only one HAL_OUT pin is permitted.  This is equivalent"]
#[doc = "to connecting two output pins together in an electronic circuit."]
#[doc = "(HAL_IO pins can be thought of as tri-state outputs.)"]
pub type hal_pin_dir_t = ::std::os::raw::c_int;
pub const hal_param_dir_t_HAL_RO: hal_param_dir_t = 64;
pub const hal_param_dir_t_HAL_RW: hal_param_dir_t = 192;
#[doc = " HAL parameters also have a direction attribute.  For parameters,"]
#[doc = "the attribute determines whether the user can write the value"]
#[doc = "of the parameter, or simply read it.  HAL_RO parameters are"]
#[doc = "read-only, and HAL_RW ones are writable with 'halcmd setp'."]
pub type hal_param_dir_t = ::std::os::raw::c_uint;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type rtapi_s8 = i8;
pub type rtapi_s16 = i16;
pub type rtapi_s32 = i32;
pub type rtapi_s64 = i64;
pub type rtapi_intptr_t = isize;
pub type rtapi_u8 = u8;
pub type rtapi_u16 = u16;
pub type rtapi_u32 = u32;
pub type rtapi_u64 = u64;
pub type rtapi_uintptr_t = usize;
pub type hal_bit_t = bool;
pub type hal_u32_t = rtapi_u32;
pub type hal_s32_t = rtapi_s32;
pub type hal_port_t = ::std::os::raw::c_int;
pub type real_t = f64;
pub type ireal_t = rtapi_u64;
#[doc = " HAL \"data union\" structure"]
#[doc = " This structure may hold any type of hal data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union hal_data_u {
    pub b: hal_bit_t,
    pub s: hal_s32_t,
    pub u: hal_u32_t,
    pub f: real_t,
    pub p: hal_port_t,
}
#[test]
fn bindgen_test_layout_hal_data_u() {
    const UNINIT: ::std::mem::MaybeUninit<hal_data_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hal_data_u>(),
        8usize,
        concat!("Size of: ", stringify!(hal_data_u))
    );
    assert_eq!(
        ::std::mem::align_of::<hal_data_u>(),
        8usize,
        concat!("Alignment of ", stringify!(hal_data_u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_data_u),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_data_u),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_data_u),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_data_u),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_data_u),
            "::",
            stringify!(p)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct hal_port_shm_t {
    pub read: ::std::os::raw::c_uint,
    pub write: ::std::os::raw::c_uint,
    pub size: ::std::os::raw::c_uint,
    pub buff: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_hal_port_shm_t() {
    const UNINIT: ::std::mem::MaybeUninit<hal_port_shm_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hal_port_shm_t>(),
        12usize,
        concat!("Size of: ", stringify!(hal_port_shm_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hal_port_shm_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hal_port_shm_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_port_shm_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_port_shm_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_port_shm_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buff) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_port_shm_t),
            "::",
            stringify!(buff)
        )
    );
}
extern "C" {
    #[doc = "                      \"LOCKING\" FUNCTIONS                             *"]
    #[doc = "locking types defined in hal.h"]
    #[doc = "HAL_LOCK_NONE -locks none"]
    #[doc = "HAL_LOCK_* - intermediate locking levels"]
    #[doc = "HAL_LOCK_ALL - locks everything"]
    pub fn hal_set_lock(lock_type: ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The 'hal_get_lock()' function returns the current locking level"]
    #[doc = "locking types defined in hal.h"]
    #[doc = "HAL_LOCK_NONE -locks none"]
    #[doc = "HAL_LOCK_* - intermediate locking levels"]
    #[doc = "HAL_LOCK_ALL - locks everything"]
    pub fn hal_get_lock() -> ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " The 'hal_pin_xxx_new()' functions create a new 'pin' object."]
    #[doc = "Once a pin has been created, it can be linked to a signal object"]
    #[doc = "using hal_link().  A pin contains a pointer, and the component"]
    #[doc = "that owns the pin can dereference the pointer to access whatever"]
    #[doc = "signal is linked to the pin.  (If no signal is linked, it points"]
    #[doc = "to a dummy signal.)"]
    #[doc = "There are eight functions, one for each of the data types that"]
    #[doc = "the HAL supports.  Pins may only be linked to signals of the same"]
    #[doc = "type."]
    #[doc = "'name' is the name of the new pin.  It must be no longer than HAL_NAME_LEN."]
    #[doc = "If there is already a pin with the same name the call will fail."]
    #[doc = "'dir' is the pin direction.  It indicates whether the pin is"]
    #[doc = "an input or output from the component."]
    #[doc = "'data_ptr_addr' is the address of the pointer that the component"]
    #[doc = "will use for the pin.  When the pin is linked to a signal, the"]
    #[doc = "pointer at 'data_ptr_addr' will be changed to point to the signal"]
    #[doc = "data location.  'data_ptr_addr' must point to memory allocated by"]
    #[doc = "hal_malloc().  Typically the component allocates space for a data"]
    #[doc = "structure with hal_malloc(), and 'data_ptr_addr' is the address"]
    #[doc = "of a member of that structure."]
    #[doc = "'comp_id' is the ID of the component that will 'own' the"]
    #[doc = "variable.  Normally it should be the ID of the caller, but in"]
    #[doc = "some cases, a user mode component may be doing setup for a"]
    #[doc = "realtime component, so the ID should be that of the realtime"]
    #[doc = "component that will actually be using the pin."]
    #[doc = "If successful, the hal_pin_xxx_new() functions return 0."]
    #[doc = "On failure they return a negative error code."]
    pub fn hal_pin_bit_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut hal_bit_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_pin_float_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut real_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_pin_u32_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut hal_u32_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_pin_s32_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut hal_s32_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_pin_port_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut hal_port_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The hal_pin_XXX_newf family of functions are similar to"]
    #[doc = "hal_pin_XXX_new except that they also do printf-style formatting to compute"]
    #[doc = "the pin name"]
    #[doc = "If successful, the hal_pin_xxx_newf() functions return 0."]
    #[doc = "On failure they return a negative error code."]
    pub fn hal_pin_bit_newf(
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut hal_bit_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_pin_float_newf(
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut real_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_pin_u32_newf(
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut hal_u32_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_pin_s32_newf(
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut hal_s32_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_pin_port_newf(
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut hal_port_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_pin_new()' creates a new 'pin' object.  It is a generic"]
    #[doc = "version of the eight functions above.  It is provided ONLY for"]
    #[doc = "those special cases where a generic function is needed.  It is"]
    #[doc = "STRONGLY recommended that the functions above be used instead,"]
    #[doc = "because they check the type of 'data_ptr_addr' against the pin"]
    #[doc = "type at compile time.  Using this function requires a cast of"]
    #[doc = "the 'data_ptr_addr' argument that defeats type checking and can"]
    #[doc = "cause subtle bugs."]
    #[doc = "'name', 'dir', 'data_ptr_addr' and 'comp_id' are the same as in"]
    #[doc = "the functions above."]
    #[doc = "'type' is the hal type of the new pin - the type of data that"]
    #[doc = "will be passed in/out of the component through the new pin."]
    #[doc = "If successful, hal_pin_new() returns 0.  On failure"]
    #[doc = "it returns a negative error code."]
    pub fn hal_pin_new(
        name: *const ::std::os::raw::c_char,
        type_: hal_type_t,
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut ::std::os::raw::c_void,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_pin_alias()' assigns an alternate name, aka an alias, to"]
    #[doc = "a pin.  Once assigned, the pin can be referred to by either its"]
    #[doc = "original name or the alias.  Calling this function with 'alias'"]
    #[doc = "set to NULL will remove any existing alias."]
    pub fn hal_pin_alias(
        pin_name: *const ::std::os::raw::c_char,
        alias: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_signal_new()' creates a new signal object.  Once a signal has"]
    #[doc = "been created, pins can be linked to it with hal_link().  The signal"]
    #[doc = "object contains the actual storage for the signal data.  Pin objects"]
    #[doc = "linked to the signal have pointers that point to the data."]
    #[doc = "'name' is the name of the new signal.  It must be no longer than"]
    #[doc = "HAL_NAME_LEN.  If there is already a signal with the same"]
    #[doc = "name the call will fail."]
    #[doc = "'type' is the data type handled by the signal.  Pins can only be"]
    #[doc = "linked to a signal of the same type."]
    #[doc = "Note that the actual address of the data storage for the signal is"]
    #[doc = "not accessible.  The data can be accessed only by linking a pin to"]
    #[doc = "the signal.  Also note that signals, unlike pins, do not have"]
    #[doc = "'owners'.  Once created, a signal remains in place until either it"]
    #[doc = "is deleted, or the last HAL component exits."]
    #[doc = "If successful, 'hal_signal_new() returns 0.  On failure"]
    #[doc = "it returns a negative error code."]
    pub fn hal_signal_new(
        name: *const ::std::os::raw::c_char,
        type_: hal_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_signal_delete()' deletes a signal object.  Any pins linked to"]
    #[doc = "the object are unlinked."]
    #[doc = "'name' is the name of the signal to be deleted."]
    #[doc = "If successful, 'hal_signal_delete()' returns 0.  On"]
    #[doc = "failure, it returns a negative error code."]
    pub fn hal_signal_delete(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_link()' links a pin to a signal.  'pin_name' and 'sig_name' are"]
    #[doc = "strings containing the pin and signal names.  If the pin is already"]
    #[doc = "linked to the desired signal, the command succeeds.  If the pin is"]
    #[doc = "already linked to some other signal, it is an error.  In either"]
    #[doc = "case, the existing connection is not modified.  (Use 'hal_unlink'"]
    #[doc = "to break an existing connection.)  If the signal already has other"]
    #[doc = "pins linked to it, they are unaffected - one signal can be linked"]
    #[doc = "to many pins, but a pin can be linked to only one signal."]
    #[doc = "On success, hal_link() returns 0, on failure it returns a"]
    #[doc = "negative error code."]
    pub fn hal_link(
        pin_name: *const ::std::os::raw::c_char,
        sig_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_unlink()' unlinks any signal from the specified pin.  'pin_name'"]
    #[doc = "is a string containing the pin name."]
    #[doc = "On success, hal_unlink() returns 0, on failure it"]
    #[doc = "returns a negative error code."]
    pub fn hal_unlink(pin_name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The 'hal_param_xxx_new()' functions create a new 'parameter' object."]
    #[doc = "A parameter is a value that is only used inside a component, but may"]
    #[doc = "need to be initialized or adjusted from outside the component to set"]
    #[doc = "up the system properly."]
    #[doc = "Once a parameter has been created, it's value can be changed using"]
    #[doc = "the 'hal_param_xxx_set()' functions."]
    #[doc = "There are eight functions, one for each of the data types that"]
    #[doc = "the HAL supports.  Pins may only be linked to signals of the same"]
    #[doc = "type."]
    #[doc = "'name' is the name of the new parameter.  It must be no longer than"]
    #[doc = ".HAL_NAME_LEN.  If there is already a parameter with the same"]
    #[doc = "name the call will fail."]
    #[doc = "'dir' is the parameter direction.  HAL_RO parameters are read only from"]
    #[doc = "outside, and are written to by the component itself, typically to provide a"]
    #[doc = "view \"into\" the component for testing or troubleshooting.  HAL_RW"]
    #[doc = "parameters are writable from outside and also sometimes modified by the"]
    #[doc = "component itself as well."]
    #[doc = "'data_addr' is the address where the value of the parameter is to be"]
    #[doc = "stored.  'data_addr' must point to memory allocated by hal_malloc()."]
    #[doc = "Typically the component allocates space for a data structure with"]
    #[doc = "hal_malloc(), and 'data_addr' is the address of a member of that"]
    #[doc = "structure.  Creating the parameter does not initialize or modify the"]
    #[doc = "value at *data_addr - the component should load a reasonable default"]
    #[doc = "value."]
    #[doc = "'comp_id' is the ID of the component that will 'own' the parameter."]
    #[doc = "Normally it should be the ID of the caller, but in some cases, a"]
    #[doc = "user mode component may be doing setup for a realtime component, so"]
    #[doc = "the ID should be that of the realtime component that will actually"]
    #[doc = "be using the parameter."]
    #[doc = "If successful, the hal_param_xxx_new() functions return 0."]
    #[doc = "On failure they return a negative error code."]
    pub fn hal_param_bit_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_param_dir_t,
        data_addr: *mut hal_bit_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_float_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_param_dir_t,
        data_addr: *mut real_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_u32_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_param_dir_t,
        data_addr: *mut hal_u32_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_s32_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_param_dir_t,
        data_addr: *mut hal_s32_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " printf_style-style versions of hal_param_XXX_new"]
    pub fn hal_param_bit_newf(
        dir: hal_param_dir_t,
        data_addr: *mut hal_bit_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_float_newf(
        dir: hal_param_dir_t,
        data_addr: *mut real_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_u32_newf(
        dir: hal_param_dir_t,
        data_addr: *mut hal_u32_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_s32_newf(
        dir: hal_param_dir_t,
        data_addr: *mut hal_s32_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_param_new()' creates a new 'parameter' object.  It is a generic"]
    #[doc = "version of the eight functions above.  It is provided ONLY for those"]
    #[doc = "special cases where a generic function is needed.  It is STRONGLY"]
    #[doc = "recommended that the functions above be used instead, because they"]
    #[doc = "check the type of 'data_addr' against the parameter type at compile"]
    #[doc = "time.  Using this function requires a cast of the 'data_addr' argument"]
    #[doc = "that defeats type checking and can cause subtle bugs."]
    #[doc = "'name', 'data_addr' and 'comp_id' are the same as in the"]
    #[doc = "functions above."]
    #[doc = "'type' is the hal type of the new parameter - the type of data"]
    #[doc = "that will be stored in the parameter."]
    #[doc = "'dir' is the parameter direction.  HAL_RO parameters are read only from"]
    #[doc = "outside, and are written to by the component itself, typically to provide a"]
    #[doc = "view \"into\" the component for testing or troubleshooting.  HAL_RW"]
    #[doc = "parameters are writable from outside and also sometimes modified by the"]
    #[doc = "component itself as well."]
    #[doc = "If successful, hal_param_new() returns 0.  On failure"]
    #[doc = "it returns a negative error code."]
    pub fn hal_param_new(
        name: *const ::std::os::raw::c_char,
        type_: hal_type_t,
        dir: hal_param_dir_t,
        data_addr: *mut ::std::os::raw::c_void,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The 'hal_param_xxx_set()' functions modify the value of a parameter."]
    #[doc = "'name' is the name of the parameter that is to be set.  The"]
    #[doc = "parameter type must match the function type, and the parameter"]
    #[doc = "must not be read-only."]
    #[doc = "'value' is the value to be loaded into the parameter."]
    #[doc = "On success, the hal_param_xxx_set() functions return 0,"]
    #[doc = "and on failure they return a negative error code."]
    pub fn hal_param_bit_set(
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_float_set(
        name: *const ::std::os::raw::c_char,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_u32_set(
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_s32_set(
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_param_alias()' assigns an alternate name, aka an alias, to"]
    #[doc = "a parameter.  Once assigned, the parameter can be referred to by"]
    #[doc = "either its original name or the alias.  Calling this function"]
    #[doc = "with 'alias' set to NULL will remove any existing alias."]
    pub fn hal_param_alias(
        pin_name: *const ::std::os::raw::c_char,
        alias: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_param_set()' is a generic function that sets the value of a"]
    #[doc = "parameter.  It is provided ONLY for those special cases where a"]
    #[doc = "generic function is needed.  It is STRONGLY recommended that the"]
    #[doc = "functions above be used instead, because they are simpler and less"]
    #[doc = "prone to errors."]
    #[doc = "'name', is the same as in the functions above."]
    #[doc = "'type' is the hal type of the the data at *value_addr, and must"]
    #[doc = "match the type of the parameter.  The parameter must not be"]
    #[doc = "read only."]
    #[doc = "'value_addr' is a pointer to the new value of the parameter."]
    #[doc = "The data at that location will be interpreted according to the"]
    #[doc = "type of the parameter."]
    #[doc = "If successful, hal_param_set() returns 0.  On failure"]
    #[doc = "it returns a negative error code."]
    pub fn hal_param_set(
        name: *const ::std::os::raw::c_char,
        type_: hal_type_t,
        value_addr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_get_pin_value_by_name()' gets the value of any arbitrary HAL pin by"]
    #[doc = " pin name."]
    #[doc = ""]
    #[doc = " The 'type' and 'data' args are pointers to the returned values.  The function"]
    #[doc = " returns 0 if successful, or -1 on error.  If 'connected' is non-NULL, its"]
    #[doc = " value will be true if a signal is connected."]
    pub fn hal_get_pin_value_by_name(
        name: *const ::std::os::raw::c_char,
        type_: *mut hal_type_t,
        data: *mut *mut hal_data_u,
        connected: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_get_signal_value_by_name()' returns the value of any arbitrary HAL"]
    #[doc = " signal by signal name."]
    #[doc = ""]
    #[doc = " The 'type' and 'data' args are pointers to the returned values.  The function"]
    #[doc = " returns 0 if successful, or -1 on error.  If 'has_writers' is non-NULL, its"]
    #[doc = " value will be true if the signal has writers."]
    pub fn hal_get_signal_value_by_name(
        name: *const ::std::os::raw::c_char,
        type_: *mut hal_type_t,
        data: *mut *mut hal_data_u,
        has_writers: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_get_param_value_by_name()' returns the value of any arbitrary HAL"]
    #[doc = " parameter by parameter name."]
    #[doc = ""]
    #[doc = " The 'type' and 'data' args are pointers to the returned values.  The function"]
    #[doc = " returns 0 if successful, or -1 on error."]
    pub fn hal_get_param_value_by_name(
        name: *const ::std::os::raw::c_char,
        type_: *mut hal_type_t,
        data: *mut *mut hal_data_u,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_export_funct() makes a realtime function provided by a"]
    #[doc = "component available to the system.  A subsequent call to"]
    #[doc = "hal_add_funct_to_thread() can be used to schedule the"]
    #[doc = "execution of the function as needed by the system."]
    #[doc = "'name' is the name of the new function.  It must be no longer"]
    #[doc = "than HAL_NAME_LEN.  This is the name as it would appear in an ini"]
    #[doc = "file, which does not need to be the same as the C function name."]
    #[doc = "'funct' is a pointer to the function code.  'funct' must be"]
    #[doc = "the address of a function that accepts a void pointer and"]
    #[doc = "a long int.  The pointer will be set to the value 'arg' below,"]
    #[doc = "and the long will be set to the thread period in nanoseconds."]
    #[doc = "'arg' is a void pointer that will be passed to the function"]
    #[doc = "each time it is called.  This is useful when one actual"]
    #[doc = "C function will be exported several times with different HAL"]
    #[doc = "names, perhaps to deal with multiple instances of a hardware"]
    #[doc = "device."]
    #[doc = "'uses_fp' should be non-zero if the function uses floating"]
    #[doc = "point.  When in doubt, make it non-zero.  If you are sure"]
    #[doc = "that the function doesn't use the FPU, then set 'uses_fp'"]
    #[doc = "to zero."]
    #[doc = "'reentrant' should be zero unless the function (and any"]
    #[doc = "hardware it accesses) is completely reentrant.  If reentrant"]
    #[doc = "is non-zero, the function may be prempted and called again"]
    #[doc = "before the first call completes."]
    #[doc = "'comp_id' is the ID of the calling component, as returned by"]
    #[doc = "a call to hal_init()."]
    #[doc = "On success, hal_export_funct() returns 0, on failure"]
    #[doc = "it returns a negative error code."]
    #[doc = "Call only from realtime init code, not from user space or"]
    #[doc = "realtime code."]
    pub fn hal_export_funct(
        name: *const ::std::os::raw::c_char,
        funct: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_long),
        >,
        arg: *mut ::std::os::raw::c_void,
        uses_fp: ::std::os::raw::c_int,
        reentrant: ::std::os::raw::c_int,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_create_thread() establishes a realtime thread that will"]
    #[doc = "execute one or more HAL functions periodically."]
    #[doc = "'name' is the name of the thread, which must be unique in"]
    #[doc = "the system.  It must be no longer than HAL_NAME_LEN."]
    #[doc = "'period_nsec' is the desired period of the thread, in nano-"]
    #[doc = "seconds.  All threads must run at an integer multiple of the"]
    #[doc = "fastest thread, and the fastest thread must be created first."]
    #[doc = "In general, threads should be created in order, from the"]
    #[doc = "fastest to the slowest.  HAL assigns decreasing priorities to"]
    #[doc = "threads that are created later, so creating them from fastest"]
    #[doc = "to slowest results in rate monotonic priority scheduling,"]
    #[doc = "usually a good thing."]
    #[doc = "'uses_fp' should be non-zero if the thread will call any"]
    #[doc = "functions that use floating point.  In general, it should"]
    #[doc = "be non-zero for most threads, with the possible exception"]
    #[doc = "of the very fastest, most critical thread in a system."]
    #[doc = "On success, hal_create_thread() returns a positive integer"]
    #[doc = "thread ID.  On failure, returns an error code as defined"]
    #[doc = "above.  Call only from realtime init code, not from user"]
    #[doc = "space or realtime code."]
    pub fn hal_create_thread(
        name: *const ::std::os::raw::c_char,
        period_nsec: ::std::os::raw::c_ulong,
        uses_fp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_thread_delete() deletes a realtime thread."]
    #[doc = "'name' is the name of the thread, which must have been created"]
    #[doc = "by 'hal_create_thread()'."]
    #[doc = "On success, hal_thread_delete() returns 0, on"]
    #[doc = "failure it returns a negative error code."]
    #[doc = "Call only from realtime init code, not from user"]
    #[doc = "space or realtime code."]
    pub fn hal_thread_delete(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_add_funct_to_thread() adds a function exported by a"]
    #[doc = "realtime HAL component to a realtime thread.  This determines"]
    #[doc = "how often and in what order functions are executed."]
    #[doc = "'funct_name' is the name of the function, as specified in"]
    #[doc = "a call to hal_export_funct()."]
    #[doc = "'thread_name' is the name of the thread to which the function"]
    #[doc = "should be added.  When the thread runs, the functions will"]
    #[doc = "be executed in the order in which they were added to the"]
    #[doc = "thread."]
    #[doc = "'position' is the desired location within the thread. This"]
    #[doc = "determines when the function will run, in relation to other"]
    #[doc = "functions in the thread.  A positive number indicates the"]
    #[doc = "desired location as measured from the beginning of the thread,"]
    #[doc = "and a negative is measured from the end.  So +1 means this"]
    #[doc = "function will become the first one to run, +5 means it will"]
    #[doc = "be the fifth one to run, -2 means it will be next to last,"]
    #[doc = "and -1 means it will be last.  Zero is illegal."]
    #[doc = "Returns 0, or a negative error code.    Call"]
    #[doc = "only from within user space or init code, not from"]
    #[doc = "realtime code."]
    pub fn hal_add_funct_to_thread(
        funct_name: *const ::std::os::raw::c_char,
        thread_name: *const ::std::os::raw::c_char,
        position: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_del_funct_from_thread() removes a function from a thread."]
    #[doc = "'funct_name' is the name of the function, as specified in"]
    #[doc = "a call to hal_export_funct()."]
    #[doc = "'thread_name' is the name of a thread which currently calls"]
    #[doc = "the function."]
    #[doc = "Returns 0, or a negative error code.    Call"]
    #[doc = "only from within user space or init code, not from"]
    #[doc = "realtime code."]
    pub fn hal_del_funct_from_thread(
        funct_name: *const ::std::os::raw::c_char,
        thread_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_start_threads() starts all threads that have been created."]
    #[doc = "This is the point at which realtime functions start being called."]
    #[doc = "On success it returns 0, on failure a negative"]
    #[doc = "error code."]
    pub fn hal_start_threads() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_stop_threads() stops all threads that were previously"]
    #[doc = "started by hal_start_threads().  It should be called before"]
    #[doc = "any component that is part of a system exits."]
    #[doc = "On success it returns 0, on failure a negative"]
    #[doc = "error code."]
    pub fn hal_stop_threads() -> ::std::os::raw::c_int;
}
#[doc = " HAL 'constructor' typedef"]
#[doc = "If it is not NULL, this points to a function which can construct a new"]
#[doc = "instance of its component.  Return value is >=0 for success,"]
#[doc = "<0 for error."]
pub type constructor = ::std::option::Option<
    unsafe extern "C" fn(
        prefix: *mut ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " hal_set_constructor() sets the constructor function for this component"]
    pub fn hal_set_constructor(
        comp_id: ::std::os::raw::c_int,
        make: constructor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_port_read reads count bytes from the port into dest."]
    #[doc = "This function should only be called by the component that owns"]
    #[doc = "the IN PORT pin."]
    #[doc = "returns"]
    #[doc = "true: count bytes were read into dest"]
    #[doc = "false: no bytes were read into dest"]
    pub fn hal_port_read(
        port: hal_port_t,
        dest: *mut ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " hal_port_peek operates the same as hal_port_read but no bytes are consumed"]
    #[doc = "from the input port. Repeated calls to hal_port_peek will return the same data."]
    #[doc = "This function should only be called by the component that owns the IN PORT pin."]
    #[doc = "returns"]
    #[doc = "true: count bytes were read into dest"]
    #[doc = "false: no bytes were read into dest"]
    pub fn hal_port_peek(
        port: hal_port_t,
        dest: *mut ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " hal_port_peek_commit advances the read position in the port buffer"]
    #[doc = "by count bytes. A hal_port_peek followed by a hal_port_peek_commit"]
    #[doc = "with the same count value would function equivalently to"]
    #[doc = "hal_port_read given the same count value. This function should only"]
    #[doc = "be called by the component that owns the IN PORT pin."]
    #[doc = "returns:"]
    #[doc = "true: count readable bytes were skipped and are no longer accessible"]
    #[doc = "false: no bytes wer skipped"]
    pub fn hal_port_peek_commit(port: hal_port_t, count: ::std::os::raw::c_uint) -> bool;
}
extern "C" {
    #[doc = " hal_port_write writes count bytes from src into the port."]
    #[doc = "This function should only be called by the component that owns"]
    #[doc = "the OUT PORT pin."]
    #[doc = "returns:"]
    #[doc = "true: count bytes were written"]
    #[doc = "false: no bytes were written into dest"]
    pub fn hal_port_write(
        port: hal_port_t,
        src: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " hal_port_readable returns the number of bytes available"]
    #[doc = "for reading from the port."]
    pub fn hal_port_readable(port: hal_port_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " hal_port_writable returns the number of bytes that"]
    #[doc = "can be written into the port"]
    pub fn hal_port_writable(port: hal_port_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " hal_port_buffer_size returns the total number of bytes"]
    #[doc = "that a port can buffer"]
    pub fn hal_port_buffer_size(port: hal_port_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " hal_port_clear emptys a given port of all data"]
    #[doc = "without consuming any of it."]
    #[doc = "hal_port_clear should only be called by a reader"]
    pub fn hal_port_clear(port: hal_port_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hal_stream_data {
    pub f: real_t,
    pub b: bool,
    pub s: i32,
    pub u: u32,
}
#[test]
fn bindgen_test_layout_hal_stream_data() {
    const UNINIT: ::std::mem::MaybeUninit<hal_stream_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hal_stream_data>(),
        8usize,
        concat!("Size of: ", stringify!(hal_stream_data))
    );
    assert_eq!(
        ::std::mem::align_of::<hal_stream_data>(),
        8usize,
        concat!("Alignment of ", stringify!(hal_stream_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_stream_data),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_stream_data),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_stream_data),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_stream_data),
            "::",
            stringify!(u)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hal_stream_t {
    pub comp_id: ::std::os::raw::c_int,
    pub shmem_id: ::std::os::raw::c_int,
    pub fifo: *mut hal_stream_shm,
}
#[test]
fn bindgen_test_layout_hal_stream_t() {
    const UNINIT: ::std::mem::MaybeUninit<hal_stream_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hal_stream_t>(),
        16usize,
        concat!("Size of: ", stringify!(hal_stream_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hal_stream_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hal_stream_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comp_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_stream_t),
            "::",
            stringify!(comp_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shmem_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_stream_t),
            "::",
            stringify!(shmem_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fifo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_stream_t),
            "::",
            stringify!(fifo)
        )
    );
}
extern "C" {
    #[doc = " create and attach a stream"]
    pub fn hal_stream_create(
        stream: *mut hal_stream_t,
        comp: ::std::os::raw::c_int,
        key: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        typestring: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " detach and destroy an open stream"]
    pub fn hal_stream_destroy(stream: *mut hal_stream_t);
}
extern "C" {
    #[doc = " attach to an existing stream"]
    pub fn hal_stream_attach(
        stream: *mut hal_stream_t,
        comp: ::std::os::raw::c_int,
        key: ::std::os::raw::c_int,
        typestring: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " detach from an open stream"]
    pub fn hal_stream_detach(stream: *mut hal_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " stream introspection"]
    pub fn hal_stream_element_count(stream: *mut hal_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_stream_element_type(
        stream: *mut hal_stream_t,
        idx: ::std::os::raw::c_int,
    ) -> hal_type_t;
}
extern "C" {
    pub fn hal_stream_read(
        stream: *mut hal_stream_t,
        buf: *mut hal_stream_data,
        sampleno: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_stream_readable(stream: *mut hal_stream_t) -> bool;
}
extern "C" {
    pub fn hal_stream_depth(stream: *mut hal_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_stream_maxdepth(stream: *mut hal_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_stream_num_underruns(stream: *mut hal_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_stream_num_overruns(stream: *mut hal_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_stream_write(
        stream: *mut hal_stream_t,
        buf: *mut hal_stream_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_stream_writable(stream: *mut hal_stream_t) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __spawn_action {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hal_stream_shm {
    pub _address: u8,
}
