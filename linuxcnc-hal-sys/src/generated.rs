/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __GNUC_VA_LIST: u32 = 1;
pub const RTAPI_NAME_LEN: u32 = 31;
pub const RTAPI_NO_FP: u32 = 0;
pub const RTAPI_USES_FP: u32 = 1;
pub const LINUX_VERSION_CODE: u32 = 0;
pub const _SPAWN_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const POSIX_SPAWN_RESETIDS: u32 = 1;
pub const POSIX_SPAWN_SETPGROUP: u32 = 2;
pub const POSIX_SPAWN_SETSIGDEF: u32 = 4;
pub const POSIX_SPAWN_SETSIGMASK: u32 = 8;
pub const POSIX_SPAWN_SETSCHEDPARAM: u32 = 16;
pub const POSIX_SPAWN_SETSCHEDULER: u32 = 32;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const HAL_NAME_LEN: u32 = 47;
pub const HAL_LOCK_NONE: u32 = 0;
pub const HAL_LOCK_LOAD: u32 = 1;
pub const HAL_LOCK_CONFIG: u32 = 2;
pub const HAL_LOCK_PARAMS: u32 = 4;
pub const HAL_LOCK_RUN: u32 = 8;
pub const HAL_LOCK_TUNE: u32 = 3;
pub const HAL_LOCK_ALL: u32 = 255;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _INTTYPES_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const RTAPI_INT8_MAX: u32 = 127;
pub const RTAPI_INT8_MIN: i32 = -128;
pub const RTAPI_UINT8_MAX: u32 = 255;
pub const RTAPI_INT16_MAX: u32 = 32767;
pub const RTAPI_INT16_MIN: i32 = -32768;
pub const RTAPI_UINT16_MAX: u32 = 65535;
pub const RTAPI_INT32_MAX: u32 = 2147483647;
pub const RTAPI_INT32_MIN: i32 = -2147483648;
pub const RTAPI_UINT32_MAX: u32 = 4294967295;
pub const HAL_STREAM_MAX_PINS: u32 = 21;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    #[doc = " @brief Sets up the RTAPI.\n\n It must be called by any module that intends to use the API, before any other\n RTAPI calls.\n @param modname Can optionally point to a string that identifies the module.\n                The string will be truncated at ::RTAPI_NAME_LEN characters.\n                If @c modname is @c NULL, the system will assign a name.\n @return On success, returns a positive integer module ID, which is used for\n         subsequent calls to rtapi_xxx_new(), rtapi_xxx_delete(), and\n         rtapi_exit(). Negative value on failure.\n @note Call only from within user or init/cleanup code, not from realtime\n       tasks."]
    pub fn rtapi_init(modname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Shuts down and cleans up the RTAPI.\n\n It must be called prior to exit by any module that called rtapi_init().\n rtapi_exit() may attempt to clean up any tasks, shared memory, and other\n resources allocated by the module, but should not be relied on to replace\n proper cleanup code within the module.\n @param module_id ID returned when that module called rtapi_init().\n @return 0 on success, negative value on failure.\n @note Call only from user or init/cleanup code, not from realtime tasks."]
    pub fn rtapi_exit(module_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Format and store a string in a buffer with a specified maximum length.\n\n Works like snprintf() from the normal C library, except that it may not\n handle long longs. It is provided here because some RTOS kernels don't\n provide a realtime safe version of the function, and those that do don't\n provide support for printing doubles. On systems with a good kernel\n snprintf(), or in user space, this function simply calls the normal\n snprintf().\n @note May be called from user, init/cleanup, and realtime code."]
    pub fn rtapi_snprintf(
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_ulong,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Works like vsnprintf() from the normal C library, except that it\n doesn't handle long longs.\n\n It is provided here because some RTOS kernels don't provide a realtime safe\n version of the function, and those that do don't provide support for printing\n doubles. On systems with a good kernel vsnprintf(), or in user space, this\n function simply calls the normal vsnrintf().\n @note May be called from user, init/cleanup, and realtime code."]
    pub fn rtapi_vsnprintf(
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_ulong,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Prints a printf() style message.\n\n Depending on the RTOS and whether the program is being compiled for user\n space or realtime, the message may be printed to @c stdout, @c stderr, or to\n a kernel message log, etc. The calling syntax and format string is similar\n to printf() except that floating point and long longs are NOT supported in\n realtime and may not be supported in user space. For some RTOS's, a 80 byte\n buffer is used, so the format line and arguments should not produce a line\n more than 80 bytes long. (The buffer is protected against overflow.) Does not\n block, but can take a fairly long time, depending on the format string and\n OS.\n @note May be called from user, init/cleanup, and realtime code."]
    pub fn rtapi_print(fmt: *const ::std::os::raw::c_char, ...);
}
pub const msg_level_t_RTAPI_MSG_NONE: msg_level_t = 0;
pub const msg_level_t_RTAPI_MSG_ERR: msg_level_t = 1;
pub const msg_level_t_RTAPI_MSG_WARN: msg_level_t = 2;
pub const msg_level_t_RTAPI_MSG_INFO: msg_level_t = 3;
pub const msg_level_t_RTAPI_MSG_DBG: msg_level_t = 4;
pub const msg_level_t_RTAPI_MSG_ALL: msg_level_t = 5;
#[doc = " Message levels"]
pub type msg_level_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Prints a printf-style message when the level is less than or equal to\n the current message level set by rtapi_set_msg_level().\n @note May be called from user, init/cleanup, and realtime code."]
    pub fn rtapi_print_msg(level: msg_level_t, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " @brief Set the maximum level of message to print.\n\n In userspace code, each component has its own independent message level.\n In realtime code, all components share a single message level.\n @param level Maximum level of message to print, should be one of\n              ::msg_level_t.\n @return 0 for success or @c -EINVAL if the level is out of range."]
    pub fn rtapi_set_msg_level(level: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the message level set by the last call to rtapi_set_msg_level()"]
    pub fn rtapi_get_msg_level() -> ::std::os::raw::c_int;
}
#[doc = " @brief Set the message handler.\n\n rtapi_get_msg_handler() and rtapi_set_msg_handler() access the function\n pointer used by rtapi_print() and rtapi_print_msg(). By default, messages\n appear in the kernel log, but by replacing the handler a user of the rtapi\n library can send the messages to another destination.\n @note Call from real-time init/cleanup code only.\n @note When called from rtapi_print(), @c level is ::RTAPI_MSG_ALL,\n       a level which should not normally be used with rtapi_print_msg()."]
pub type rtapi_msg_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        level: msg_level_t,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ),
>;
extern "C" {
    pub fn rtapi_set_msg_handler(handler: rtapi_msg_handler_t);
}
extern "C" {
    pub fn rtapi_get_msg_handler() -> rtapi_msg_handler_t;
}
extern "C" {
    #[doc = " @brief Sets the basic time interval for realtime tasks.\n All periodic tasks will run at an integer multiple of this period. The first\n call to rtapi_clock_set_period() with @c nsecs greater than zero will start\n the clock, using @c nsecs as the clock period in nano-seconds.  Due to\n hardware and RTOS limitations, the actual period may not be exactly what was\n requested.\n @return On success, the actual clock period if it is available, otherwise it\n         returns the requested period. If the requested period is outside the\n         limits imposed by the hardware or RTOS, it returns @c -EINVAL and\n         does not start the clock. Once the clock is started, subsequent calls\n         with non-zero @c nsecs return @c -EINVAL and have no effect. Calling\n         rtapi_clock_set_period() with @c nsecs set to zero queries the clock,\n         returning the current clock period, or zero if the clock has not yet\n         been started.\n @note Call only from within init/cleanup code, not from realtime tasks."]
    pub fn rtapi_clock_set_period(nsecs: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Simple delay, intended only for short delays, since it simply loops,\n        wasting CPU cycles.\n\n Any call to rtapi_delay() requesting a delay longer than the max will delay\n for the max time only. rtapi_delay_max() should be called before using\n rtapi_delay() to make sure the required delays can be achieved. The actual\n resolution of the delay may be as good as one nano-second, or as bad as a\n several microseconds.\n @param nsec Desired delay in nano-seconds.\n @note This timing function is only available in realtime modules. User\n       processes may not call them!"]
    pub fn rtapi_delay(nsec: ::std::os::raw::c_long);
}
extern "C" {
    #[doc = " @brief Returns the max delay permitted for rtapi_delay().\n @return Max delay permitted in nano-seconds.\n @note This timing function is only available in realtime modules. User\n       processes may not call them!"]
    pub fn rtapi_delay_max() -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " @brief Returns the current time in nanoseconds.\n\n Depending on the RTOS, this may be time since boot, or time since the clock\n period was set, or some other time. Its absolute value means nothing, but it\n is monotonically increasing and can be used to schedule future events, or to\n time the duration of some activity. Returns a 64 bit value. The resolution of\n the returned value may be as good as one nano-second, or as poor as several\n microseconds.\n\n Experience has shown that the implementation of this function in some\n RTOS/Kernel combinations is horrible. It can take up to  several\n microseconds, which is at least 100 times longer than it should, and perhaps\n a thousand times longer. Use it only if you MUST have results in seconds\n instead of clocks, and use it sparingly. See rtapi_get_clocks() instead.\n\n Most time measurements are relative, and should be done like this:\n @code\n deltat = (long int)(end_time - start_time);\n @endcode\n where @c end_time and @c start_time are longlong values returned from\n rtapi_get_time(), and @c deltat is an ordinary long int (32 bits). This will\n work for times up to about 2 seconds.\n\n @note May be called from init/cleanup code, and from within realtime tasks.\n @note The longlong may be poorly supported on some platforms, especially\n       within kernel space.\n @note rtapi_print() will NOT print longlong values.\n @return Current time in nanoseconds"]
    pub fn rtapi_get_time() -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " @brief Returns the current time in CPU clocks.\n\n It is  fast, since it just reads the TSC in the CPU instead of calling a\n kernel or RTOS function. Of course, times measured in CPU clocks are not as\n convenient, but for relative measurements this works fine. Its absolute value\n means nothing, but it is monotonically increasing* and can be used to\n schedule future events, or to time the duration of some activity. (* on SMP\n machines, the two TSC's may get out of sync, so if a task reads the TSC, gets\n swapped to the other CPU, and reads again, the value may decrease. RTAPI\n tries to force all RT tasks to run on one CPU.)\n\n Most time measurements are relative, and should be done like this:\n @code\n deltat = (long int)(end_time - start_time);\n @endcode\n where @c end_time and @c start_time are longlong values returned from\n rtapi_get_time(), and deltat is an ordinary long int (32 bits). This will\n work for times up to a second or so, depending on the CPU clock frequency.\n It is best used for millisecond and microsecond scale measurements though.\n @return A 64 bit value.  The resolution of the returned value is one CPU\n         clock, which is usually a few nanoseconds to a fraction of a\n         nanosecond.\n @note May be called from init/cleanup code, and from within realtime tasks.\n @note longlong math may be poorly supported on some platforms, especially in\n       kernel space. Also note that rtapi_print() will NOT print longlong.\n"]
    pub fn rtapi_get_clocks() -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " @brief Sets task priority to the highest possible value.\n @return Value for the highest priority, which is 0.\n @note Call these functions only from within init/cleanup code, not from\n       realtime tasks."]
    pub fn rtapi_prio_highest() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Sets task priority to the lowest possible value.\n @return Value for the lowest priority, which is 0xFFF.\n @note Call these functions only from within init/cleanup code, not from\n       realtime tasks."]
    pub fn rtapi_prio_lowest() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Returns the next higher priority\n @param prio Previous priority.\n @note Call these functions only from within init/cleanup code, not from\n       realtime tasks."]
    pub fn rtapi_prio_next_higher(prio: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Returns the next lower priority\n @param prio Previous priority.\n @note Call these functions only from within init/cleanup code, not from\n       realtime tasks."]
    pub fn rtapi_prio_next_lower(prio: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creates but does not start a realtime task.\n\n The task is created in the \"paused\" state. To start it, call either\n rtapi_task_start() for periodic tasks, or rtapi_task_resume() for\n free-running tasks.\n\n @c taskcode is the name of a function taking one int and returning void,\n which contains the task code. @c arg will be passed to @c taskcode as an\n arbitrary void pointer when the task is started, and can be used to pass any\n amount of data to the task (by pointing to a struct, or other such tricks).\n\n @c uses_fp is a flag that tells the OS whether the task uses floating point\n so it can save the FPU registers on a task switch. Failing to save registers\n when needed causes the dreaded \"NAN bug\", so most tasks should set @c\n uses_fp to ::RTAPI_USES_FP. If a task definitely does not use floating\n point, setting @c uses_fp to ::RTAPI_NO_FP saves a few microseconds per task\n switch.\n @param taskcode Pointer to the function to be called when the task is\n                 started.\n @param arg Argument to be passed to the taskcode function.\n @param prio Priority of the task, determined by one of rtapi_prio_xxxx().\n @param owner ID of the module that is making the call see rtapi_init().\n @param stacksize The amount of stack to be used for the task, be generous,\n                  hardware interrupts may use the same stack.\n @param uses_fp Whether the task uses floating point set with ::RTAPI_NO_FP\n                or ::RTAPI_USES_FP.\n @return On success, returns a positive integer task ID, @c task_id. This ID\n         is used for all subsequent calls that need to act on the task. On\n         failure, returns a negative error code as listed above.\n @note Call only from within init/cleanup code, not from realtime tasks."]
    pub fn rtapi_task_new(
        taskcode: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        arg: *mut ::std::os::raw::c_void,
        prio: ::std::os::raw::c_int,
        owner: ::std::os::raw::c_int,
        stacksize: ::std::os::raw::c_ulong,
        uses_fp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Deletes a task.\n\n It frees memory associated with @c task, and does any other cleanup needed.\n If the task has been started, you should pause it before deleting it.\n @param task_id ID from a previous call to rtapi_task_new().\n @return 0 on success, negative value on failure.\n @note Call only from within init/cleanup code, not from realtime tasks."]
    pub fn rtapi_task_delete(task_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Starts a task in periodic mode.\n\n @c period_nsec will be rounded to the nearest multiple of the global clock\n period. A task period less than the clock period (including zero) will be set\n equal to the clock period.\n @param task_id ID from a previous call to rtapi_task_new().\n @param period_nsec Period in nanoseconds.\n @return 0 on success, negative value on failure. The task must be in the\n         \"paused\" state, or it will return @c -EINVAL.\n @note Call only from within init/cleanup code, not from realtime tasks."]
    pub fn rtapi_task_start(
        task_id: ::std::os::raw::c_int,
        period_nsec: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Suspends execution of the current task until the next period.\n\n The task must be periodic, if not, the result is undefined.\n @return The function will return at the beginning of the next period.\n @note Call only from within a realtime task."]
    pub fn rtapi_wait();
}
extern "C" {
    #[doc = " @brief Starts a task in free-running mode.\n\n A free running task runs continuously until either:\n    1) It is preempted by a higher priority task. It will resume as soon as the\n       higher priority task releases the CPU.\n    2) It calls a blocking function, like rtapi_sem_take(). It will resume\n       when the function unblocks.\n    3) it is returned to the \"paused\" state by rtapi_task_pause().\n @param task_id ID from a previous call to rtapi_task_new().\n @return 0 on success, negative value on failure. The task must be in the\n         \"paused\" state, or it will return @c -EINVAL.\n @note May be called from init/cleanup code, and from within realtime tasks."]
    pub fn rtapi_task_resume(task_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Stop task  execution and change to the \"paused\" state.\n\n The task will resume execution when either rtapi_task_resume() or\n rtapi_task_start() is called. The task can be free-running or periodic\n @param task_id ID from a previous call to rtapi_task_new().\n @return 0 on success, negative value on failure.\n @note May called from any task, or from init or cleanup code, not just from\n       the task that is to be paused.\n @note May be called from init/cleanup code, and from within realtime tasks."]
    pub fn rtapi_task_pause(task_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the @c task_id of the current task or -EINVAL.\n @note May be called from init/cleanup code, and from within realtime tasks."]
    pub fn rtapi_task_self() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Allocates a block of shared memory.\n\n All modules wishing to access the same memory must use the same @c key. The\n block will be at least @c size bytes, and may be rounded up. Allocating many\n small blocks may be very wasteful. When a particular block is allocated for\n the first time, all bytes are zeroed. Subsequent allocations of the same\n block by other modules or processes will not touch the contents of the block.\n @param key Identifier for the memory block must be non-zero.\n @param module_id ID of the calling module.\n @param size Desired size of the shared memory block, in bytes.\n @return On success, it returns a positive integer ID, which is used for\nall subsequent calls dealing with the block. On failure it returns a\nnegative error code.\n @note Call only from within user or init/cleanup code, not from realtime\n       tasks."]
    pub fn rtapi_shmem_new(
        key: ::std::os::raw::c_int,
        module_id: ::std::os::raw::c_int,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Frees the shared memory block associated with @c shmem_id.\n @param shmem_id ID of the shared memory block created with rtapi_shmem_new().\n @param module_id ID of the calling module.\n @return 0 on success, negative value on failure.\n @note Call only from within user or init/cleanup code, not from realtime\n       tasks."]
    pub fn rtapi_shmem_delete(
        shmem_id: ::std::os::raw::c_int,
        module_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Sets @c *ptr to point to shared memory block associated with\n         @c shmem_id.\n @param shmem_id ID of the shared memory block created with rtapi_shmem_new().\n @param ptr Pointer to shared memory block.\n @return 0 on success, negative value on failure.\n @note May be called from user code, init/cleanup code, or realtime tasks."]
    pub fn rtapi_shmem_getptr(
        shmem_id: ::std::os::raw::c_int,
        ptr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Create a new semaphore.\n\n All modules wishing to use the same semaphore, must specify the same @c key.\n @param key Identifier for the semaphore, and must be non-zero.\n @param module_id Is the ID of the module making the call, see rtapi_init().\n @return On success, it returns a positive integer semaphore ID, sem_id, which\n         is used for all subsequent calls dealing with the semaphore. On\n         failure it returns a negative error code.\n @note Call only from within init/cleanup code, not from realtime tasks.\n @note Only available in realtime modules. User processes may not call them!\n       Consider the mutex functions in rtapi_mutex.h instead."]
    pub fn rtapi_sem_new(
        key: ::std::os::raw::c_int,
        module_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Delete a semaphore.\n\n Any tasks blocked on @c sem will resume execution.\n @param sem_id Semaphore ID returned by a previous call to rtapi_sem_new().\n @param module_id is the ID of the calling module.\n @return 0 on success, negative value on failure.\n @note Call only from within init/cleanup code, not from realtime tasks."]
    pub fn rtapi_sem_delete(
        sem_id: ::std::os::raw::c_int,
        module_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Unlocks a semaphore.\n\n If a higher priority task is blocked on the semaphore, the calling task will\n block and the higher priority task will begin to run.\n @param sem_id Semaphore ID returned by a previous call to rtapi_sem_new().\n @return 0 on success, negative value on failure.\n @note May be called from init/cleanup code, and from within realtime tasks."]
    pub fn rtapi_sem_give(sem_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Locks a semaphore.\n @param sem_id Semaphore ID returned by a previous call to rtapi_sem_new().\n @return 0 or @c  -EINVAL. If the semaphore is unlocked it returns 0\n         immediately. If the semaphore is locked, the calling task blocks\n         until the semaphore is unlocked, then it returns 0.\n @note Call only from within a realtime task."]
    pub fn rtapi_sem_take(sem_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Non-blocking attempt to lock a semaphore.\n @param sem_id Semaphore ID returned by a previous call to rtapi_sem_new().\n @return If the semaphore is unlocked, it returns 0. On failure @c -EINVAL.\n         If the semaphore is locked it does not block, instead it returns @c\n         -EBUSY, and the caller can decide how to deal with the situation.\n @note Call only from within a realtime task."]
    pub fn rtapi_sem_try(sem_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Creates a realtime fifo.\n\n All modules wishing to access the same fifo must use the same @c key.\n @param key Identifies the fifo, must be non-zero.\n @param module_id ID of the calling module. see rtapi_init().\n @param size Size of the fifo.\n @param mode Either @c 'R' or @c 'W', read or write access to the fifo.\n @return On success a positive integer ID, the @c fifo_id, which is used for\n         subsequent calls dealing with the fifo. On failure, returns a\n         negative error code.\n @note Call only from within user or init/cleanup code, not from realtime\n       tasks.\n @note RTAI fifos require \\f$(stacksize >= fifosize + 256)\\f$ to avoid oops\n       messages on removal."]
    pub fn rtapi_fifo_new(
        key: ::std::os::raw::c_int,
        module_id: ::std::os::raw::c_int,
        size: ::std::os::raw::c_ulong,
        mode: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Closes the fifo associated with @c fifo_id.\n @param fifo_id ID of the fifo to close.\n @param module_id ID of the calling module.\n @return 0 on success, negative value on failure.\n @note Call only from within user or init/cleanup code, not from realtime\n       tasks."]
    pub fn rtapi_fifo_delete(
        fifo_id: ::std::os::raw::c_int,
        module_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtapi_fifo_read(
        fifo_id: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtapi_fifo_write(
        fifo_id: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set up a handler for a hardware interrupt.\n @param irq_num Interrupt number.\n @param owner ID of the calling module, see rtapi_init().\n @param handler Function pointer,taking no arguments and returning void.\n                @c handler will be called when the interrupt occurs.\n @return 0 on successfully installing the handler, negative value on failure.\n @note The simulated RTOS does not support interrupts.\n @note Call only from within init/cleanup code, not from realtime tasks."]
    pub fn rtapi_irq_new(
        irq_num: ::std::os::raw::c_uint,
        owner: ::std::os::raw::c_int,
        handler: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Removes an interrupt handler that was previously installed by\n        rtapi_assign_interrupt_handler().\n @param irq_num Interrupt number.\n @return 0 on success, negative value on failure\n @note Call only from within init/cleanup code, not from realtime tasks.\n @warning Removing a realtime module without freeing any handlers it has\n          installed will almost certainly crash the box."]
    pub fn rtapi_irq_delete(irq_num: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable interrupt.\n\n This is presumably ones that have handlers assigned to them.\n @param irq Interrupt number.\n @return Always returns 0.\n @note May be called from init/cleanup code, and from within realtime tasks."]
    pub fn rtapi_enable_interrupt(irq: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Disable interrupt.\n\n This is presumably ones that have handlers assigned to them.\n @param irq Interrupt number.\n @return Always returns 0.\n @note May be called from init/cleanup code, and from within realtime tasks."]
    pub fn rtapi_disable_interrupt(irq: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Write @c byte to a hardware I/O @c port.\n @param byte Byte to write.\n @param port Address of the I/O port.\n @note May be called from init/cleanup code, and from within realtime tasks.\n @note This function does nothing on the simulated RTOS.\n @note Many platforms provide an inline outb() that is faster."]
    pub fn rtapi_outb(byte: ::std::os::raw::c_uchar, port: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " @brief Read byte from @c port.\n @param port Address of the I/O port.\n @return Bytes read from the given I/O @c port.\n @note May be called from init/cleanup code, and from within realtime tasks.\n @note This function always returns zero on the simulated RTOS.\n @note Many platforms provide an inline inb() that is faster."]
    pub fn rtapi_inb(port: ::std::os::raw::c_uint) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn simple_strtol(
        nptr: *const ::std::os::raw::c_char,
        endptr: *mut *mut ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::std::mem::MaybeUninit<sched_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_set_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_spawnattr_t {
    pub __flags: ::std::os::raw::c_short,
    pub __pgrp: pid_t,
    pub __sd: sigset_t,
    pub __ss: sigset_t,
    pub __sp: sched_param,
    pub __policy: ::std::os::raw::c_int,
    pub __pad: [::std::os::raw::c_int; 16usize],
}
#[test]
fn bindgen_test_layout_posix_spawnattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<posix_spawnattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<posix_spawnattr_t>(),
        336usize,
        concat!("Size of: ", stringify!(posix_spawnattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<posix_spawnattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(posix_spawnattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawnattr_t),
            "::",
            stringify!(__flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pgrp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawnattr_t),
            "::",
            stringify!(__pgrp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawnattr_t),
            "::",
            stringify!(__sd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawnattr_t),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawnattr_t),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__policy) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawnattr_t),
            "::",
            stringify!(__policy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawnattr_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_spawn_file_actions_t {
    pub __allocated: ::std::os::raw::c_int,
    pub __used: ::std::os::raw::c_int,
    pub __actions: *mut __spawn_action,
    pub __pad: [::std::os::raw::c_int; 16usize],
}
#[test]
fn bindgen_test_layout_posix_spawn_file_actions_t() {
    const UNINIT: ::std::mem::MaybeUninit<posix_spawn_file_actions_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<posix_spawn_file_actions_t>(),
        80usize,
        concat!("Size of: ", stringify!(posix_spawn_file_actions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<posix_spawn_file_actions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(posix_spawn_file_actions_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__allocated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawn_file_actions_t),
            "::",
            stringify!(__allocated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__used) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawn_file_actions_t),
            "::",
            stringify!(__used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__actions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawn_file_actions_t),
            "::",
            stringify!(__actions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_spawn_file_actions_t),
            "::",
            stringify!(__pad)
        )
    );
}
extern "C" {
    pub fn posix_spawn(
        __pid: *mut pid_t,
        __path: *const ::std::os::raw::c_char,
        __file_actions: *const posix_spawn_file_actions_t,
        __attrp: *const posix_spawnattr_t,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnp(
        __pid: *mut pid_t,
        __file: *const ::std::os::raw::c_char,
        __file_actions: *const posix_spawn_file_actions_t,
        __attrp: *const posix_spawnattr_t,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_init(__attr: *mut posix_spawnattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_destroy(__attr: *mut posix_spawnattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_getsigdefault(
        __attr: *const posix_spawnattr_t,
        __sigdefault: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_setsigdefault(
        __attr: *mut posix_spawnattr_t,
        __sigdefault: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_getsigmask(
        __attr: *const posix_spawnattr_t,
        __sigmask: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_setsigmask(
        __attr: *mut posix_spawnattr_t,
        __sigmask: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_getflags(
        __attr: *const posix_spawnattr_t,
        __flags: *mut ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_setflags(
        _attr: *mut posix_spawnattr_t,
        __flags: ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_getpgroup(
        __attr: *const posix_spawnattr_t,
        __pgroup: *mut pid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_setpgroup(
        __attr: *mut posix_spawnattr_t,
        __pgroup: pid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_getschedpolicy(
        __attr: *const posix_spawnattr_t,
        __schedpolicy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_setschedpolicy(
        __attr: *mut posix_spawnattr_t,
        __schedpolicy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_getschedparam(
        __attr: *const posix_spawnattr_t,
        __schedparam: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawnattr_setschedparam(
        __attr: *mut posix_spawnattr_t,
        __schedparam: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawn_file_actions_init(
        __file_actions: *mut posix_spawn_file_actions_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawn_file_actions_destroy(
        __file_actions: *mut posix_spawn_file_actions_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawn_file_actions_addopen(
        __file_actions: *mut posix_spawn_file_actions_t,
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        __mode: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawn_file_actions_addclose(
        __file_actions: *mut posix_spawn_file_actions_t,
        __fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_spawn_file_actions_adddup2(
        __file_actions: *mut posix_spawn_file_actions_t,
        __fd: ::std::os::raw::c_int,
        __newfd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtapi_spawn_as_root(
        pid: *mut pid_t,
        path: *const ::std::os::raw::c_char,
        file_actions: *const posix_spawn_file_actions_t,
        attrp: *const posix_spawnattr_t,
        argv: *const *mut ::std::os::raw::c_char,
        envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtapi_spawnp_as_root(
        pid: *mut pid_t,
        path: *const ::std::os::raw::c_char,
        file_actions: *const posix_spawn_file_actions_t,
        attrp: *const posix_spawnattr_t,
        argv: *const *mut ::std::os::raw::c_char,
        envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtapi_is_kernelspace() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtapi_is_realtime() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rtapi_open_as_root(
        filename: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_init()' is called by a HAL component before any other hal\nfunction is called, to open the HAL shared memory block and\ndo other initialization.\n'name' is the name of the component.  It must be unique in the\nsystem.  It must be no longer than HAL_NAME_LEN.\nOn success, hal_init() returns a positive integer component ID,\nwhich is used for subsequent calls to hal_xxx_new() and\nhal_exit().  On failure, returns an error code (see above).\n'hal_init()' calls rtapi_init(), so after calling hal_init(), a\ncomponent can use any rtapi functions.  The component ID returned\nby 'hal_init()' is also the RTAPI module ID for the associated\nmodule, and can be used when calling rtapi functions.\nCall only from within user space or init/cleanup code, not from\nrealtime code."]
    pub fn hal_init(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_exit()' must be called before a HAL component exits, to\nfree resources associated with the component.\n'comp_id' is the ID of the component as returned from its initial\ncall to 'hal_init()'.  'hal_exit()' will remove the component's\nrealtime functions (if any) from realtime threads.  It also\nremoves all pins and parameters exported by the component.  If\nthe component created _any_ threads, when it exits _all_ threads\nwill be stopped, and the ones it created will be deleted.\nIt is assumed that the system will no longer function correctly\nafter a component is removed, but this cleanup will prevent\ncrashes when the component's code and data is unmapped.\n'hal_exit()' calls 'rtapi_exit()', so any rtapi reaources\nallocated should be discarded before calling hal_exit(), and\nrtapi functions should not be called afterwards.\nOn success, hal_exit() returns 0, on failure it\nreturns a negative error code."]
    pub fn hal_exit(comp_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_malloc() allocates a block of memory from the main HAL\nshared memory area.  It should be used by all components to\nallocate memory for HAL pins and parameters.\nIt allocates 'size' bytes, and returns a pointer to the\nallocated space, or NULL (0) on error.  The returned pointer\nwill be properly aligned for any variable HAL supports (see\nHAL_TYPE below.)\nThe allocator is very simple, and there is no 'free'.  It is\nassumed that a component will allocate all the memory it needs\nduring initialization.  The entire HAL shared memory area is\nfreed when the last component calls hal_exit().  This means\nthat if you continuously install and remove one component\nwhile other components are present, you eventually will fill\nup the shared memory and an install will fail.  Removing\nall components completely clears memory and you start\nfresh."]
    pub fn hal_malloc(size: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " hal_ready() indicates that this component is ready.  This allows\nhalcmd 'loadusr -W hal_example' to wait until the userspace\ncomponent 'hal_example' is ready before continuing."]
    pub fn hal_ready(comp_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_set_unready() sets a component state to unready so\nadditional pins can be added.  A subsequent call to\nhal_ready() must be issued to make the component ready\nagain. Kinematics modules created with halcompile use\nthis function to add pins to a parent component."]
    pub fn hal_set_unready(comp_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_unready() indicates that this component is ready.  This allows\nhalcmd 'loadusr -W hal_example' to wait until the userspace\ncomponent 'hal_example' is ready before continuing."]
    pub fn hal_unready(comp_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_comp_name() returns the name of the given component, or NULL\nif comp_id is not a loaded component"]
    pub fn hal_comp_name(comp_id: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
pub const hal_type_t_HAL_TYPE_UNSPECIFIED: hal_type_t = -1;
pub const hal_type_t_HAL_TYPE_UNINITIALIZED: hal_type_t = 0;
pub const hal_type_t_HAL_BIT: hal_type_t = 1;
pub const hal_type_t_HAL_FLOAT: hal_type_t = 2;
pub const hal_type_t_HAL_S32: hal_type_t = 3;
pub const hal_type_t_HAL_U32: hal_type_t = 4;
pub const hal_type_t_HAL_S64: hal_type_t = 6;
pub const hal_type_t_HAL_U64: hal_type_t = 7;
pub const hal_type_t_HAL_PORT: hal_type_t = 5;
pub const hal_type_t_HAL_TYPE_MAX: hal_type_t = 6;
#[doc = " HAL pins and signals are typed, and the HAL only allows pins\nto be attached to signals of the same type.\nAll HAL types can be read or written atomically.  (Read-modify-\nwrite operations are not atomic.)\nNote that when a component reads or writes one of its pins, it\nis actually reading or writing the signal linked to that pin, by\nway of the pointer.\n'hal_type_t' is an enum used to identify the type of a pin, signal,\nor parameter."]
pub type hal_type_t = ::std::os::raw::c_int;
pub const hal_pin_dir_t_HAL_DIR_UNSPECIFIED: hal_pin_dir_t = -1;
pub const hal_pin_dir_t_HAL_IN: hal_pin_dir_t = 16;
pub const hal_pin_dir_t_HAL_OUT: hal_pin_dir_t = 32;
pub const hal_pin_dir_t_HAL_IO: hal_pin_dir_t = 48;
#[doc = " HAL pins have a direction attribute.  A pin may be an input to\nthe HAL component, an output, or it may be bidirectional.\nAny number of HAL_IN or HAL_IO pins may be connected to the same\nsignal, but only one HAL_OUT pin is permitted.  This is equivalent\nto connecting two output pins together in an electronic circuit.\n(HAL_IO pins can be thought of as tri-state outputs.)"]
pub type hal_pin_dir_t = ::std::os::raw::c_int;
pub const hal_param_dir_t_HAL_RO: hal_param_dir_t = 64;
pub const hal_param_dir_t_HAL_RW: hal_param_dir_t = 192;
#[doc = " HAL parameters also have a direction attribute.  For parameters,\nthe attribute determines whether the user can write the value\nof the parameter, or simply read it.  HAL_RO parameters are\nread-only, and HAL_RW ones are writable with 'halcmd setp'."]
pub type hal_param_dir_t = ::std::os::raw::c_uint;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type rtapi_s8 = i8;
pub type rtapi_s16 = i16;
pub type rtapi_s32 = i32;
pub type rtapi_s64 = i64;
pub type rtapi_intptr_t = isize;
pub type rtapi_u8 = u8;
pub type rtapi_u16 = u16;
pub type rtapi_u32 = u32;
pub type rtapi_u64 = u64;
pub type rtapi_uintptr_t = usize;
pub type hal_bit_t = bool;
pub type hal_u32_t = rtapi_u32;
pub type hal_s32_t = rtapi_s32;
pub type hal_u64_t = rtapi_u64;
pub type hal_s64_t = rtapi_s64;
pub type hal_port_t = ::std::os::raw::c_int;
pub type real_t = f64;
pub type ireal_t = rtapi_u64;
#[doc = " HAL \"data union\" structure\n This structure may hold any type of hal data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union hal_data_u {
    pub b: hal_bit_t,
    pub s: hal_s32_t,
    pub u: hal_u32_t,
    pub f: real_t,
    pub p: hal_port_t,
    pub ls: hal_s64_t,
    pub lu: hal_u64_t,
}
#[test]
fn bindgen_test_layout_hal_data_u() {
    const UNINIT: ::std::mem::MaybeUninit<hal_data_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hal_data_u>(),
        8usize,
        concat!("Size of: ", stringify!(hal_data_u))
    );
    assert_eq!(
        ::std::mem::align_of::<hal_data_u>(),
        8usize,
        concat!("Alignment of ", stringify!(hal_data_u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_data_u),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_data_u),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_data_u),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_data_u),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_data_u),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ls) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_data_u),
            "::",
            stringify!(ls)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lu) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_data_u),
            "::",
            stringify!(lu)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct hal_port_shm_t {
    pub read: ::std::os::raw::c_uint,
    pub write: ::std::os::raw::c_uint,
    pub size: ::std::os::raw::c_uint,
    pub buff: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_hal_port_shm_t() {
    const UNINIT: ::std::mem::MaybeUninit<hal_port_shm_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hal_port_shm_t>(),
        12usize,
        concat!("Size of: ", stringify!(hal_port_shm_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hal_port_shm_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hal_port_shm_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_port_shm_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_port_shm_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_port_shm_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buff) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_port_shm_t),
            "::",
            stringify!(buff)
        )
    );
}
extern "C" {
    #[doc = " The 'hal_get_lock()' function returns the current locking level\nlocking types defined in hal.h\nHAL_LOCK_NONE -locks none\nHAL_LOCK_* - intermediate locking levels\nHAL_LOCK_ALL - locks everything"]
    pub fn hal_get_lock() -> ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " The 'hal_pin_xxx_new()' functions create a new 'pin' object.\nOnce a pin has been created, it can be linked to a signal object\nusing hal_link().  A pin contains a pointer, and the component\nthat owns the pin can dereference the pointer to access whatever\nsignal is linked to the pin.  (If no signal is linked, it points\nto a dummy signal.)\nThere are eight functions, one for each of the data types that\nthe HAL supports.  Pins may only be linked to signals of the same\ntype.\n'name' is the name of the new pin.  It must be no longer than HAL_NAME_LEN.\nIf there is already a pin with the same name the call will fail.\n'dir' is the pin direction.  It indicates whether the pin is\nan input or output from the component.\n'data_ptr_addr' is the address of the pointer that the component\nwill use for the pin.  When the pin is linked to a signal, the\npointer at 'data_ptr_addr' will be changed to point to the signal\ndata location.  'data_ptr_addr' must point to memory allocated by\nhal_malloc().  Typically the component allocates space for a data\nstructure with hal_malloc(), and 'data_ptr_addr' is the address\nof a member of that structure.\n'comp_id' is the ID of the component that will 'own' the\nvariable.  Normally it should be the ID of the caller, but in\nsome cases, a user mode component may be doing setup for a\nrealtime component, so the ID should be that of the realtime\ncomponent that will actually be using the pin.\nIf successful, the hal_pin_xxx_new() functions return 0.\nOn failure they return a negative error code."]
    pub fn hal_pin_bit_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut hal_bit_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_pin_float_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut real_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_pin_u32_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut hal_u32_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_pin_s32_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut hal_s32_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_pin_u64_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut hal_u64_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_pin_s64_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut hal_s64_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_pin_port_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut hal_port_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The hal_pin_XXX_newf family of functions are similar to\nhal_pin_XXX_new except that they also do printf-style formatting to compute\nthe pin name\nIf successful, the hal_pin_xxx_newf() functions return 0.\nOn failure they return a negative error code."]
    pub fn hal_pin_bit_newf(
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut hal_bit_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_pin_float_newf(
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut real_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_pin_u32_newf(
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut hal_u32_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_pin_s32_newf(
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut hal_s32_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_pin_u64_newf(
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut hal_u64_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_pin_s64_newf(
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut hal_s64_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_pin_port_newf(
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut hal_port_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_pin_new()' creates a new 'pin' object.  It is a generic\nversion of the eight functions above.  It is provided ONLY for\nthose special cases where a generic function is needed.  It is\nSTRONGLY recommended that the functions above be used instead,\nbecause they check the type of 'data_ptr_addr' against the pin\ntype at compile time.  Using this function requires a cast of\nthe 'data_ptr_addr' argument that defeats type checking and can\ncause subtle bugs.\n'name', 'dir', 'data_ptr_addr' and 'comp_id' are the same as in\nthe functions above.\n'type' is the hal type of the new pin - the type of data that\nwill be passed in/out of the component through the new pin.\nIf successful, hal_pin_new() returns 0.  On failure\nit returns a negative error code."]
    pub fn hal_pin_new(
        name: *const ::std::os::raw::c_char,
        type_: hal_type_t,
        dir: hal_pin_dir_t,
        data_ptr_addr: *mut *mut ::std::os::raw::c_void,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_pin_alias()' assigns an alternate name, aka an alias, to\na pin.  Once assigned, the pin can be referred to by either its\noriginal name or the alias.  Calling this function with 'alias'\nset to NULL will remove any existing alias."]
    pub fn hal_pin_alias(
        pin_name: *const ::std::os::raw::c_char,
        alias: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_signal_new()' creates a new signal object.  Once a signal has\nbeen created, pins can be linked to it with hal_link().  The signal\nobject contains the actual storage for the signal data.  Pin objects\nlinked to the signal have pointers that point to the data.\n'name' is the name of the new signal.  It must be no longer than\nHAL_NAME_LEN.  If there is already a signal with the same\nname the call will fail.\n'type' is the data type handled by the signal.  Pins can only be\nlinked to a signal of the same type.\nNote that the actual address of the data storage for the signal is\nnot accessible.  The data can be accessed only by linking a pin to\nthe signal.  Also note that signals, unlike pins, do not have\n'owners'.  Once created, a signal remains in place until either it\nis deleted, or the last HAL component exits.\nIf successful, 'hal_signal_new() returns 0.  On failure\nit returns a negative error code."]
    pub fn hal_signal_new(
        name: *const ::std::os::raw::c_char,
        type_: hal_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_signal_delete()' deletes a signal object.  Any pins linked to\nthe object are unlinked.\n'name' is the name of the signal to be deleted.\nIf successful, 'hal_signal_delete()' returns 0.  On\nfailure, it returns a negative error code."]
    pub fn hal_signal_delete(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_link()' links a pin to a signal.  'pin_name' and 'sig_name' are\nstrings containing the pin and signal names.  If the pin is already\nlinked to the desired signal, the command succeeds.  If the pin is\nalready linked to some other signal, it is an error.  In either\ncase, the existing connection is not modified.  (Use 'hal_unlink'\nto break an existing connection.)  If the signal already has other\npins linked to it, they are unaffected - one signal can be linked\nto many pins, but a pin can be linked to only one signal.\nOn success, hal_link() returns 0, on failure it returns a\nnegative error code."]
    pub fn hal_link(
        pin_name: *const ::std::os::raw::c_char,
        sig_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_unlink()' unlinks any signal from the specified pin.  'pin_name'\nis a string containing the pin name.\nOn success, hal_unlink() returns 0, on failure it\nreturns a negative error code."]
    pub fn hal_unlink(pin_name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The 'hal_param_xxx_new()' functions create a new 'parameter' object.\nA parameter is a value that is only used inside a component, but may\nneed to be initialized or adjusted from outside the component to set\nup the system properly.\nOnce a parameter has been created, it's value can be changed using\nthe 'hal_param_xxx_set()' functions.\nThere are eight functions, one for each of the data types that\nthe HAL supports.  Pins may only be linked to signals of the same\ntype.\n'name' is the name of the new parameter.  It must be no longer than\n.HAL_NAME_LEN.  If there is already a parameter with the same\nname the call will fail.\n'dir' is the parameter direction.  HAL_RO parameters are read only from\noutside, and are written to by the component itself, typically to provide a\nview \"into\" the component for testing or troubleshooting.  HAL_RW\nparameters are writable from outside and also sometimes modified by the\ncomponent itself as well.\n'data_addr' is the address where the value of the parameter is to be\nstored.  'data_addr' must point to memory allocated by hal_malloc().\nTypically the component allocates space for a data structure with\nhal_malloc(), and 'data_addr' is the address of a member of that\nstructure.  Creating the parameter does not initialize or modify the\nvalue at *data_addr - the component should load a reasonable default\nvalue.\n'comp_id' is the ID of the component that will 'own' the parameter.\nNormally it should be the ID of the caller, but in some cases, a\nuser mode component may be doing setup for a realtime component, so\nthe ID should be that of the realtime component that will actually\nbe using the parameter.\nIf successful, the hal_param_xxx_new() functions return 0.\nOn failure they return a negative error code."]
    pub fn hal_param_bit_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_param_dir_t,
        data_addr: *mut hal_bit_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_float_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_param_dir_t,
        data_addr: *mut real_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_u32_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_param_dir_t,
        data_addr: *mut hal_u32_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_s32_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_param_dir_t,
        data_addr: *mut hal_s32_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_u64_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_param_dir_t,
        data_addr: *mut hal_u64_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_s64_new(
        name: *const ::std::os::raw::c_char,
        dir: hal_param_dir_t,
        data_addr: *mut hal_s64_t,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " printf_style-style versions of hal_param_XXX_new"]
    pub fn hal_param_bit_newf(
        dir: hal_param_dir_t,
        data_addr: *mut hal_bit_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_float_newf(
        dir: hal_param_dir_t,
        data_addr: *mut real_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_u32_newf(
        dir: hal_param_dir_t,
        data_addr: *mut hal_u32_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_s32_newf(
        dir: hal_param_dir_t,
        data_addr: *mut hal_s32_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_u64_newf(
        dir: hal_param_dir_t,
        data_addr: *mut hal_u64_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_s64_newf(
        dir: hal_param_dir_t,
        data_addr: *mut hal_s64_t,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_param_new()' creates a new 'parameter' object.  It is a generic\nversion of the eight functions above.  It is provided ONLY for those\nspecial cases where a generic function is needed.  It is STRONGLY\nrecommended that the functions above be used instead, because they\ncheck the type of 'data_addr' against the parameter type at compile\ntime.  Using this function requires a cast of the 'data_addr' argument\nthat defeats type checking and can cause subtle bugs.\n'name', 'data_addr' and 'comp_id' are the same as in the\nfunctions above.\n'type' is the hal type of the new parameter - the type of data\nthat will be stored in the parameter.\n'dir' is the parameter direction.  HAL_RO parameters are read only from\noutside, and are written to by the component itself, typically to provide a\nview \"into\" the component for testing or troubleshooting.  HAL_RW\nparameters are writable from outside and also sometimes modified by the\ncomponent itself as well.\nIf successful, hal_param_new() returns 0.  On failure\nit returns a negative error code."]
    pub fn hal_param_new(
        name: *const ::std::os::raw::c_char,
        type_: hal_type_t,
        dir: hal_param_dir_t,
        data_addr: *mut ::std::os::raw::c_void,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The 'hal_param_xxx_set()' functions modify the value of a parameter.\n'name' is the name of the parameter that is to be set.  The\nparameter type must match the function type, and the parameter\nmust not be read-only.\n'value' is the value to be loaded into the parameter.\nOn success, the hal_param_xxx_set() functions return 0,\nand on failure they return a negative error code."]
    pub fn hal_param_bit_set(
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_float_set(
        name: *const ::std::os::raw::c_char,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_u32_set(
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_s32_set(
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_u64_set(
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_param_s64_set(
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_param_alias()' assigns an alternate name, aka an alias, to\na parameter.  Once assigned, the parameter can be referred to by\neither its original name or the alias.  Calling this function\nwith 'alias' set to NULL will remove any existing alias."]
    pub fn hal_param_alias(
        pin_name: *const ::std::os::raw::c_char,
        alias: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_param_set()' is a generic function that sets the value of a\nparameter.  It is provided ONLY for those special cases where a\ngeneric function is needed.  It is STRONGLY recommended that the\nfunctions above be used instead, because they are simpler and less\nprone to errors.\n'name', is the same as in the functions above.\n'type' is the hal type of the the data at *value_addr, and must\nmatch the type of the parameter.  The parameter must not be\nread only.\n'value_addr' is a pointer to the new value of the parameter.\nThe data at that location will be interpreted according to the\ntype of the parameter.\nIf successful, hal_param_set() returns 0.  On failure\nit returns a negative error code."]
    pub fn hal_param_set(
        name: *const ::std::os::raw::c_char,
        type_: hal_type_t,
        value_addr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_get_pin_value_by_name()' gets the value of any arbitrary HAL pin by\n pin name.\n\n The 'type' and 'data' args are pointers to the returned values.  The function\n returns 0 if successful, or -1 on error.  If 'connected' is non-NULL, its\n value will be true if a signal is connected."]
    pub fn hal_get_pin_value_by_name(
        name: *const ::std::os::raw::c_char,
        type_: *mut hal_type_t,
        data: *mut *mut hal_data_u,
        connected: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_get_signal_value_by_name()' returns the value of any arbitrary HAL\n signal by signal name.\n\n The 'type' and 'data' args are pointers to the returned values.  The function\n returns 0 if successful, or -1 on error.  If 'has_writers' is non-NULL, its\n value will be true if the signal has writers."]
    pub fn hal_get_signal_value_by_name(
        name: *const ::std::os::raw::c_char,
        type_: *mut hal_type_t,
        data: *mut *mut hal_data_u,
        has_writers: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " 'hal_get_param_value_by_name()' returns the value of any arbitrary HAL\n parameter by parameter name.\n\n The 'type' and 'data' args are pointers to the returned values.  The function\n returns 0 if successful, or -1 on error."]
    pub fn hal_get_param_value_by_name(
        name: *const ::std::os::raw::c_char,
        type_: *mut hal_type_t,
        data: *mut *mut hal_data_u,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_export_funct() makes a realtime function provided by a\ncomponent available to the system.  A subsequent call to\nhal_add_funct_to_thread() can be used to schedule the\nexecution of the function as needed by the system.\n'name' is the name of the new function.  It must be no longer\nthan HAL_NAME_LEN.  This is the name as it would appear in an ini\nfile, which does not need to be the same as the C function name.\n'funct' is a pointer to the function code.  'funct' must be\nthe address of a function that accepts a void pointer and\na long int.  The pointer will be set to the value 'arg' below,\nand the long will be set to the thread period in nanoseconds.\n'arg' is a void pointer that will be passed to the function\neach time it is called.  This is useful when one actual\nC function will be exported several times with different HAL\nnames, perhaps to deal with multiple instances of a hardware\ndevice.\n'uses_fp' should be non-zero if the function uses floating\npoint.  When in doubt, make it non-zero.  If you are sure\nthat the function doesn't use the FPU, then set 'uses_fp'\nto zero.\n'reentrant' should be zero unless the function (and any\nhardware it accesses) is completely reentrant.  If reentrant\nis non-zero, the function may be prempted and called again\nbefore the first call completes.\n'comp_id' is the ID of the calling component, as returned by\na call to hal_init().\nOn success, hal_export_funct() returns 0, on failure\nit returns a negative error code.\nCall only from realtime init code, not from user space or\nrealtime code."]
    pub fn hal_export_funct(
        name: *const ::std::os::raw::c_char,
        funct: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_long),
        >,
        arg: *mut ::std::os::raw::c_void,
        uses_fp: ::std::os::raw::c_int,
        reentrant: ::std::os::raw::c_int,
        comp_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_export_functf is similar to hal_export_funct except that it also does\nprintf-style formatting to compute the function name.\nIf successful, it returns 0.\nOn failure it returns a negative error code."]
    pub fn hal_export_functf(
        funct: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_long),
        >,
        arg: *mut ::std::os::raw::c_void,
        uses_fp: ::std::os::raw::c_int,
        reentrant: ::std::os::raw::c_int,
        comp_id: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_create_thread() establishes a realtime thread that will\nexecute one or more HAL functions periodically.\n'name' is the name of the thread, which must be unique in\nthe system.  It must be no longer than HAL_NAME_LEN.\n'period_nsec' is the desired period of the thread, in nano-\nseconds.  All threads must run at an integer multiple of the\nfastest thread, and the fastest thread must be created first.\nIn general, threads should be created in order, from the\nfastest to the slowest.  HAL assigns decreasing priorities to\nthreads that are created later, so creating them from fastest\nto slowest results in rate monotonic priority scheduling,\nusually a good thing.\n'uses_fp' should be non-zero if the thread will call any\nfunctions that use floating point.  In general, it should\nbe non-zero for most threads, with the possible exception\nof the very fastest, most critical thread in a system.\nOn success, hal_create_thread() returns a positive integer\nthread ID.  On failure, returns an error code as defined\nabove.  Call only from realtime init code, not from user\nspace or realtime code."]
    pub fn hal_create_thread(
        name: *const ::std::os::raw::c_char,
        period_nsec: ::std::os::raw::c_ulong,
        uses_fp: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_thread_delete() deletes a realtime thread.\n'name' is the name of the thread, which must have been created\nby 'hal_create_thread()'.\nOn success, hal_thread_delete() returns 0, on\nfailure it returns a negative error code.\nCall only from realtime init code, not from user\nspace or realtime code."]
    pub fn hal_thread_delete(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_add_funct_to_thread() adds a function exported by a\nrealtime HAL component to a realtime thread.  This determines\nhow often and in what order functions are executed.\n'funct_name' is the name of the function, as specified in\na call to hal_export_funct().\n'thread_name' is the name of the thread to which the function\nshould be added.  When the thread runs, the functions will\nbe executed in the order in which they were added to the\nthread.\n'position' is the desired location within the thread. This\ndetermines when the function will run, in relation to other\nfunctions in the thread.  A positive number indicates the\ndesired location as measured from the beginning of the thread,\nand a negative is measured from the end.  So +1 means this\nfunction will become the first one to run, +5 means it will\nbe the fifth one to run, -2 means it will be next to last,\nand -1 means it will be last.  Zero is illegal.\nReturns 0, or a negative error code.    Call\nonly from within user space or init code, not from\nrealtime code."]
    pub fn hal_add_funct_to_thread(
        funct_name: *const ::std::os::raw::c_char,
        thread_name: *const ::std::os::raw::c_char,
        position: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_del_funct_from_thread() removes a function from a thread.\n'funct_name' is the name of the function, as specified in\na call to hal_export_funct().\n'thread_name' is the name of a thread which currently calls\nthe function.\nReturns 0, or a negative error code.    Call\nonly from within user space or init code, not from\nrealtime code."]
    pub fn hal_del_funct_from_thread(
        funct_name: *const ::std::os::raw::c_char,
        thread_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_start_threads() starts all threads that have been created.\nThis is the point at which realtime functions start being called.\nOn success it returns 0, on failure a negative\nerror code."]
    pub fn hal_start_threads() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_stop_threads() stops all threads that were previously\nstarted by hal_start_threads().  It should be called before\nany component that is part of a system exits.\nOn success it returns 0, on failure a negative\nerror code."]
    pub fn hal_stop_threads() -> ::std::os::raw::c_int;
}
#[doc = " HAL 'constructor' typedef\nIf it is not NULL, this points to a function which can construct a new\ninstance of its component.  Return value is >=0 for success,\n<0 for error."]
pub type constructor = ::std::option::Option<
    unsafe extern "C" fn(
        prefix: *mut ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " hal_set_constructor() sets the constructor function for this component"]
    pub fn hal_set_constructor(
        comp_id: ::std::os::raw::c_int,
        make: constructor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " hal_port_read reads count bytes from the port into dest.\nThis function should only be called by the component that owns\nthe IN PORT pin.\nreturns\ntrue: count bytes were read into dest\nfalse: no bytes were read into dest"]
    pub fn hal_port_read(
        port: hal_port_t,
        dest: *mut ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " hal_port_peek operates the same as hal_port_read but no bytes are consumed\nfrom the input port. Repeated calls to hal_port_peek will return the same data.\nThis function should only be called by the component that owns the IN PORT pin.\nreturns\ntrue: count bytes were read into dest\nfalse: no bytes were read into dest"]
    pub fn hal_port_peek(
        port: hal_port_t,
        dest: *mut ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " hal_port_peek_commit advances the read position in the port buffer\nby count bytes. A hal_port_peek followed by a hal_port_peek_commit\nwith the same count value would function equivalently to\nhal_port_read given the same count value. This function should only\nbe called by the component that owns the IN PORT pin.\nreturns:\ntrue: count readable bytes were skipped and are no longer accessible\nfalse: no bytes wer skipped"]
    pub fn hal_port_peek_commit(port: hal_port_t, count: ::std::os::raw::c_uint) -> bool;
}
extern "C" {
    #[doc = " hal_port_write writes count bytes from src into the port.\nThis function should only be called by the component that owns\nthe OUT PORT pin.\nreturns:\ntrue: count bytes were written\nfalse: no bytes were written into dest"]
    pub fn hal_port_write(
        port: hal_port_t,
        src: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " hal_port_readable returns the number of bytes available\nfor reading from the port."]
    pub fn hal_port_readable(port: hal_port_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " hal_port_writable returns the number of bytes that\ncan be written into the port"]
    pub fn hal_port_writable(port: hal_port_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " hal_port_buffer_size returns the total number of bytes\nthat a port can buffer"]
    pub fn hal_port_buffer_size(port: hal_port_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " hal_port_clear emptys a given port of all data\nwithout consuming any of it.\nhal_port_clear should only be called by a reader"]
    pub fn hal_port_clear(port: hal_port_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hal_stream_data {
    pub f: real_t,
    pub b: bool,
    pub s: i32,
    pub u: u32,
}
#[test]
fn bindgen_test_layout_hal_stream_data() {
    const UNINIT: ::std::mem::MaybeUninit<hal_stream_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hal_stream_data>(),
        8usize,
        concat!("Size of: ", stringify!(hal_stream_data))
    );
    assert_eq!(
        ::std::mem::align_of::<hal_stream_data>(),
        8usize,
        concat!("Alignment of ", stringify!(hal_stream_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_stream_data),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_stream_data),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_stream_data),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_stream_data),
            "::",
            stringify!(u)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hal_stream_t {
    pub comp_id: ::std::os::raw::c_int,
    pub shmem_id: ::std::os::raw::c_int,
    pub fifo: *mut hal_stream_shm,
}
#[test]
fn bindgen_test_layout_hal_stream_t() {
    const UNINIT: ::std::mem::MaybeUninit<hal_stream_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hal_stream_t>(),
        16usize,
        concat!("Size of: ", stringify!(hal_stream_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hal_stream_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hal_stream_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comp_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_stream_t),
            "::",
            stringify!(comp_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shmem_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_stream_t),
            "::",
            stringify!(shmem_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fifo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_stream_t),
            "::",
            stringify!(fifo)
        )
    );
}
extern "C" {
    #[doc = " create and attach a stream"]
    pub fn hal_stream_create(
        stream: *mut hal_stream_t,
        comp: ::std::os::raw::c_int,
        key: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        typestring: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " detach and destroy an open stream"]
    pub fn hal_stream_destroy(stream: *mut hal_stream_t);
}
extern "C" {
    #[doc = " attach to an existing stream"]
    pub fn hal_stream_attach(
        stream: *mut hal_stream_t,
        comp: ::std::os::raw::c_int,
        key: ::std::os::raw::c_int,
        typestring: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " detach from an open stream"]
    pub fn hal_stream_detach(stream: *mut hal_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " stream introspection"]
    pub fn hal_stream_element_count(stream: *mut hal_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_stream_element_type(
        stream: *mut hal_stream_t,
        idx: ::std::os::raw::c_int,
    ) -> hal_type_t;
}
extern "C" {
    pub fn hal_stream_read(
        stream: *mut hal_stream_t,
        buf: *mut hal_stream_data,
        sampleno: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_stream_readable(stream: *mut hal_stream_t) -> bool;
}
extern "C" {
    pub fn hal_stream_depth(stream: *mut hal_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_stream_maxdepth(stream: *mut hal_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_stream_num_underruns(stream: *mut hal_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_stream_num_overruns(stream: *mut hal_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_stream_write(
        stream: *mut hal_stream_t,
        buf: *mut hal_stream_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hal_stream_writable(stream: *mut hal_stream_t) -> bool;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __spawn_action {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hal_stream_shm {
    pub _address: u8,
}
